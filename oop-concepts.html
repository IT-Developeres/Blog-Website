<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Basics - 140 Essential Questions & Answers</title>
    <meta name="description" content="Master programming fundamentals with 140 essential questions, detailed answers, and real-world code examples. Perfect for interview preparation and skill building.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #7c3aed;
            --dark: #0f172a;
            --light: #f8fafc;
            --gray: #64748b;
            --light-gray: #e2e8f0;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background-color: #f9fafb;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 4rem 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 800;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 2rem;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Search Box */
        .search-box {
            max-width: 600px;
            margin: 0 auto;
            position: relative;
        }

        .search-box i {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
        }

        .search-box input {
            width: 100%;
            padding: 0.8rem 1rem 0.8rem 2.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .search-box input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }

        /* Sidebar Styles */
        .sidebar {
            position: sticky;
            top: 2rem;
            align-self: flex-start;
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            height: fit-content;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar h2 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--dark);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar h2 i {
            color: var(--primary);
        }

        .toc-list {
            list-style: none;
        }

        .toc-item {
            margin-bottom: 0.5rem;
        }

        .toc-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            color: var(--gray);
            text-decoration: none;
            border-radius: 6px;
            transition: var(--transition);
            font-size: 0.95rem;
        }

        .toc-link:hover, .toc-link.active {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary);
        }

        .toc-link i {
            width: 20px;
            text-align: center;
        }

        .toc-hidden {
            display: none;
        }

        .toc-toggle-btn {
            margin-left: auto;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .toc-toggle-btn:hover {
            background: rgba(37, 99, 235, 0.15);
        }

        /* Main Content Styles */
        .main-content {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: var(--shadow);
        }

        .breadcrumbs {
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: var(--gray);
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumbs a {
            color: var(--primary);
            text-decoration: none;
            transition: var(--transition);
        }

        .breadcrumbs a:hover {
            text-decoration: underline;
        }

        .breadcrumbs span {
            color: var(--gray);
        }

        /* Question Box Styles */
        .q-box {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            transition: var(--transition);
        }

        .q-box:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }

        .q-box h3 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--dark);
            font-weight: 600;
            line-height: 1.4;
        }

        .q-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            color: var(--gray);
        }

        .q-number {
            background: var(--primary);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .q-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .q-tag {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn i {
            font-size: 0.9em;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background: rgba(37, 99, 235, 0.1);
        }

        /* Answer Styles */
        .answer {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e5e7eb;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .answer.show {
            display: block;
        }

        .answer-section {
            margin-bottom: 1.5rem;
        }

        .answer-section:last-child {
            margin-bottom: 0;
        }

        .answer-section h4 {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: var(--dark);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .answer-section h4 i {
            color: var(--primary);
        }

        .answer-section p {
            margin-bottom: 1rem;
            color: #374151;
            line-height: 1.7;
        }

        /* Code Block Styles */
        pre {
            background: #1e293b;
            border-radius: 8px;
            padding: 1.25rem;
            margin: 1rem 0;
            overflow-x: auto;
            position: relative;
        }

        pre code {
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #e2e8f0;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0f172a;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            margin: 0;
            color: #94a3b8;
            font-size: 0.8rem;
            font-family: 'Fira Code', monospace;
        }

        .copy-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #94a3b8;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: var(--transition);
        }

        .copy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .copy-btn.copied {
            background: var(--success);
            color: white;
        }

        /* Pagination Styles */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 3rem;
            gap: 1rem;
        }

        .page-info {
            color: var(--gray);
            font-size: 0.95rem;
        }

        /* Back to Top Button */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 100;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .back-to-top:hover {
            background: var(--primary-dark);
            transform: translateY(-3px) scale(1.05);
        }

        /* Footer Styles */
        footer {
            background: var(--dark);
            color: white;
            padding: 3rem 2rem;
            margin-top: 4rem;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .footer-content p {
            margin-bottom: 1rem;
            color: #94a3b8;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .footer-links a {
            color: #e2e8f0;
            text-decoration: none;
        }

        .footer-links a:hover {
            color: var(--primary);
        }

        /* Responsive Styles */
        @media (max-width: 992px) {
            .container {
                grid-template-columns: 1fr;
                padding: 1.5rem;
            }

            .sidebar {
                position: static;
                margin-bottom: 2rem;
                order: -1;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 2rem 1rem;
            }

            header h1 {
                font-size: 1.75rem;
                margin-bottom: 0.75rem;
            }

            header p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }

            .search-box {
                max-width: 100%;
            }

            .search-box input {
                padding: 0.75rem 1rem 0.75rem 2.25rem;
                font-size: 0.95rem;
            }

            .container {
                padding: 1rem;
            }

            .main-content, .sidebar {
                padding: 1rem;
            }

            .q-box {
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .q-box h3 {
                font-size: 1.1rem;
                line-height: 1.3;
            }

            .q-meta {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }

            .q-tags {
                margin-bottom: 0.75rem;
            }

            .q-tag {
                font-size: 0.7rem;
                padding: 0.2rem 0.6rem;
            }

            .pagination {
                flex-direction: column;
                gap: 0.75rem;
            }

            .btn {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
                width: 100%;
                justify-content: center;
            }

            .footer-links {
                flex-direction: column;
                gap: 0.75rem;
            }

            .back-to-top {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        @media (max-width: 480px) {
            header {
                padding: 1.5rem 0.75rem;
            }

            header h1 {
                font-size: 1.5rem;
            }

            header p {
                font-size: 0.9rem;
            }

            .container {
                padding: 0.75rem;
            }

            .main-content, .sidebar {
                padding: 0.75rem;
            }

            .q-box {
                padding: 0.75rem;
            }

            .q-box h3 {
                font-size: 1rem;
            }

            .sidebar h2 {
                font-size: 1rem;
            }

            .toc-link {
                padding: 0.4rem 0.6rem;
                font-size: 0.85rem;
            }

            .q-number {
                width: 24px;
                height: 24px;
                font-size: 0.7rem;
            }

            .q-tag {
                font-size: 0.65rem;
                padding: 0.15rem 0.5rem;
            }

            pre {
                padding: 0.75rem;
                font-size: 0.8rem;
            }

            .code-header {
                padding: 0.4rem 0.75rem;
                font-size: 0.7rem;
            }

            .copy-btn {
                padding: 0.2rem 0.5rem;
                font-size: 0.65rem;
            }
        }

        /* Mobile Menu Toggle */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1001;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        .mobile-sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .mobile-sidebar {
            position: fixed;
            top: 0;
            right: -100%;
            width: 80%;
            max-width: 320px;
            height: 100%;
            background: white;
            z-index: 1001;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .mobile-sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: var(--primary);
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mobile-sidebar-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mobile-sidebar-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .mobile-sidebar-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .mobile-sidebar.active {
            right: 0;
        }

        .mobile-sidebar-overlay.active {
            display: block;
        }

        @media (max-width: 768px) {
            .mobile-menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar {
                display: none;
            }

            .mobile-sidebar .sidebar {
                display: block;
                position: static;
                margin: 0;
                padding: 1rem;
                border-radius: 0;
                box-shadow: none;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            .btn, .toc-link, .copy-btn {
                min-height: 44px;
                min-width: 44px;
            }

            .toc-link {
                padding: 0.75rem;
            }

            .q-tag {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }

        /* Improved mobile typography */
        @media (max-width: 768px) {
            body {
                font-size: 16px;
                line-height: 1.5;
            }

            .q-box p, .answer-section p {
                font-size: 0.95rem;
                line-height: 1.6;
            }
        }

        /* Better mobile spacing */
        @media (max-width: 768px) {
            .q-box {
                border-radius: 8px;
            }

            .main-content {
                border-radius: 8px;
            }

            .sidebar {
                border-radius: 8px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Programming Basics</h1>
            <p>Master the fundamentals with 140+ essential questions, detailed answers, and real-world code examples</p>
            <div class="search-box">
                <i class="fas fa-search"></i>
                <input type="text" id="searchInput" placeholder="Search questions...">
            </div>
        </div>
    </header>

    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Toggle menu">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Mobile Sidebar Overlay -->
    <div class="mobile-sidebar-overlay" id="mobileSidebarOverlay"></div>

    <!-- Mobile Sidebar -->
    <div class="mobile-sidebar" id="mobileSidebar">
        <div class="mobile-sidebar-header">
            <h3><i class="fas fa-list"></i> Menu</h3>
            <button class="mobile-sidebar-close" id="mobileSidebarClose" aria-label="Close menu">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="sidebar">
            <div class="sidebar-section">
                <h2><i class="fas fa-list"></i> Table of Contents <button class="toc-toggle-btn" id="tocToggleBtn" type="button" aria-label="Toggle table of contents"><i class="fas fa-bars"></i></button></h2>
                <ul class="toc-list toc-hidden" id="tocList">
                    <!-- Filled by JavaScript -->
                </ul>
            </div>
            
            <div class="sidebar-section">
                <h2><i class="fas fa-link"></i> Quick Links</h2>
                <ul class="toc-list">
                    <li class="toc-item"><a href="/" class="toc-link"><i class="fas fa-home"></i> Home</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-book"></i> All Topics</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-download"></i> Download PDF</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-question-circle"></i> About</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Sidebar with Table of Contents -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <h2><i class="fas fa-list"></i> Table of Contents <button class="toc-toggle-btn" id="tocToggleBtn" type="button" aria-label="Toggle table of contents"><i class="fas fa-bars"></i></button></h2>
                <ul class="toc-list toc-hidden" id="tocList">
                    <!-- Filled by JavaScript -->
                </ul>
            </div>
            
            <div class="sidebar-section">
                <h2><i class="fas fa-link"></i> Quick Links</h2>
                <ul class="toc-list">
                    <li class="toc-item"><a href="/" class="toc-link"><i class="fas fa-home"></i> Home</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-book"></i> All Topics</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-download"></i> Download PDF</a></li>
                    <li class="toc-item"><a href="#" class="toc-link"><i class="fas fa-question-circle"></i> About</a></li>
                </ul>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <div class="breadcrumbs">
                <a href="/">Home</a>
                <span>/</span>
                <a href="#">Topics</a>
                <span>/</span>
                <span>Programming Basics</span>
            </div>
            
            <h2 style="margin-bottom: 2rem;">140 Essential Programming Questions</h2>
            
            <div id="questionsContainer">
                <!-- Questions will be inserted here by JavaScript -->
            </div>
            
            <div class="pagination">
                <button class="btn" id="prevPage"><i class="fas fa-chevron-left"></i> Previous</button>
                <span id="pageInfo" class="page-info">Page 1 of 12</span>
                <button class="btn" id="nextPage">Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </main>
    </div>

    <!-- Back to top button -->
    <button class="back-to-top" id="backToTop" title="Go to top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <footer>
        <div class="footer-content">
            <p> 2025 IT Interview Hub – Programming Basics</p>
            <p>Your go-to resource for technical interview preparation</p>
            <div class="footer-links">
                <a href="/">Home</a>
                <a href="#">Topics</a>
                <a href="#">About</a>
                <a href="#">Contact</a>
                <a href="#">Privacy Policy</a>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        // Initialize syntax highlighting
        if (typeof hljs !== 'undefined') {
            hljs.highlightAll();
        }

        // Pagination variables
        let currentPage = 1;
        const questionsPerPage = 10; // Changed to show 10 questions per page
        let currentQuestions = [];

        // Questions data
        const data = [
            {
                q: "What is Object-Oriented Programming (OOP)?",
                a: "Object-Oriented Programming is a programming paradigm based on the concept of 'objects' which contain data (attributes) and code (methods). OOP organizes software design around data, rather than functions and logic. It provides four main principles: encapsulation, abstraction, inheritance, and polymorphism.",
                r: "Think of a car as an object - it has properties (color, speed) and behaviors (start, stop, accelerate).",
                tags: ["oop-basics", "concepts", "introduction"]
            },
            {
                q: "What is the difference between a class and an object?",
                a: "A class is a blueprint or template for creating objects, while an object is an instance of a class. A class defines properties and methods that objects will have, but doesn't occupy memory until instantiated. Objects are actual entities that exist in memory with their own state and behavior.",
                r: "Class = Car blueprint, Object = Your specific red Toyota Camry with VIN 12345.",
                tags: ["oop-basics", "class", "object", "instantiation"]
            },
            {
                q: "What is encapsulation in OOP?",
                a: "Encapsulation is the bundling of data (attributes) and methods that operate on the data into a single unit (class). It also involves restricting direct access to some of an object's components, which is known as data hiding. This is achieved using access modifiers like private, protected, and public.",
                r: "A bank account encapsulates balance data and provides methods like deposit() and withdraw() instead of direct access to balance.",
                tags: ["oop-principles", "encapsulation", "data-hiding", "access-modifiers"]
            },
            {
                q: "What is abstraction in OOP?",
                a: "Abstraction is the concept of hiding complex implementation details and showing only the essential features of an object. It helps reduce complexity by allowing programmers to focus on interactions at a higher level. Abstract classes and interfaces are common ways to implement abstraction.",
                r: "When you drive a car, you use the steering wheel and pedals (abstraction) without needing to know how the engine works (implementation).",
                tags: ["oop-principles", "abstraction", "abstract-class", "interface"]
            },
            {
                q: "What is inheritance in OOP?",
                a: "Inheritance is a mechanism where a new class (derived/child class) inherits properties and methods from an existing class (base/parent class). This promotes code reuse and establishes a hierarchical relationship between classes. The child class can extend, modify, or add new functionality.",
                r: "A 'SportsCar' class inherits from 'Car' class, getting all car features plus adding turbo boost functionality.",
                tags: ["oop-principles", "inheritance", "base-class", "derived-class", "code-reuse"]
            },
            {
                q: "What is polymorphism in OOP?",
                a: "Polymorphism means 'many forms' and allows objects of different classes to be treated as objects of a common superclass. It enables one interface to be used for a general class of actions. There are two types: compile-time (method overloading) and runtime (method overriding).",
                r: "A 'draw()' method works differently for Circle, Square, and Triangle objects, but you can call draw() on any shape.",
                tags: ["oop-principles", "polymorphism", "method-overloading", "method-overriding"]
            },
            {
                q: "What are access modifiers in OOP?",
                a: "Access modifiers control the visibility and accessibility of class members (fields, methods, constructors). Common modifiers are: public (accessible everywhere), private (accessible only within the same class), protected (accessible within class and subclasses), and package/default (accessible within the same package).",
                r: "A bank account's balance is private, deposit() is public, and accountNumber might be protected for subclass access.",
                tags: ["encapsulation", "access-modifiers", "visibility", "public", "private", "protected"]
            },
            {
                q: "What is recursion, and what is a base case?",
                a: "Recursion is when a function solves a problem by calling itself on a smaller version of the same problem. For recursion to be safe, it must have a base case—a condition where it stops calling itself. Without a base case (or if the base case is never reached), recursion will keep going until the program runs out of memory.",
                r: "Processing a tree structure is naturally recursive because each node can have child nodes.",
                tags: ["basics", "recursion", "control-flow"]
            },
            {
                q: "What is the difference between static and instance members?",
                a: "Static members belong to the class itself rather than to any specific instance. They are shared across all objects and can be accessed using the class name. Instance members belong to individual objects and each object has its own copy. Static methods cannot access instance members directly.",
                r: "Math.PI is static (same for all), while each Person object has its own name (instance).",
                tags: ["static", "instance", "class-members", "object-members", "memory"]
            },
            {
                q: "What is composition in OOP and how does it differ from inheritance?",
                a: "Composition is a 'has-a' relationship where a class contains objects of other classes as members. Inheritance is an 'is-a' relationship where a subclass extends a parent class. Composition provides more flexibility and avoids deep inheritance hierarchies. The principle 'favor composition over inheritance' suggests using composition when possible.",
                r: "Car has-a Engine (composition) vs SportsCar is-a Car (inheritance).",
                tags: ["composition", "inheritance", "design-patterns", "has-a", "is-a"]
            },
            {
                q: "What is method chaining in OOP?",
                a: "Method chaining is a technique where multiple method calls are made on the same object in a single statement. Each method returns the object itself (this), allowing subsequent calls. This creates fluent interfaces and makes code more readable. Common in builder patterns and query builders.",
                r: "person.setName('John').setAge(25).setEmail('john@email') chains multiple setters.",
                tags: ["method-chaining", "fluent-interface", "builder-pattern", "this"]
            },
            {
                q: "What is the difference between shallow copy and deep copy?",
                a: "Shallow copy copies the object's fields but not the objects they reference - both copies share the same nested objects. Deep copy creates copies of all nested objects recursively. Shallow copy is faster but can cause unintended side effects when modifying nested objects. Deep copy is safer but more expensive.",
                r: "Shallow: two lists pointing to same items. Deep: two independent lists with duplicate items.",
                tags: ["copying", "memory", "object-cloning", "reference-types"]
            },
            {
                q: "What is the SOLID principle in OOP?",
                a: "SOLID is an acronym for five OOP design principles: Single Responsibility (each class has one reason to change), Open/Closed (open for extension, closed for modification), Liskov Substitution (subtypes must be substitutable for base types), Interface Segregation (many specific interfaces better than one general), and Dependency Inversion (depend on abstractions, not concretions). These principles guide robust, maintainable OOP design.",
                r: "SOLID helps create flexible, reusable, and maintainable object-oriented systems.",
                tags: ["solid", "design-principles", "architecture", "best-practices"]
            },
            {
                q: "What is the difference between method overloading and method overriding?",
                a: "Method overloading is compile-time polymorphism where multiple methods have the same name but different parameters (same class). Method overriding is runtime polymorphism where a subclass provides a specific implementation of a method already defined in its superclass (different classes). Overloading changes method signature, overriding keeps the same signature.",
                r: "Overloading: calculate(int) vs calculate(double). Overriding: Dog overrides Animal's makeSound().",
                tags: ["polymorphism", "method-overloading", "method-overriding", "inheritance", "compile-time", "runtime"]
            },
            {
                q: "What is the Liskov Substitution Principle (LSP)?",
                a: "LSP states that objects of a superclass should be replaceable with objects of a subclass without affecting program correctness. Subclasses must honor the contract of their parent classes - they shouldn't strengthen preconditions or weaken postconditions. This ensures inheritance hierarchies are reliable and substitutable.",
                r: "Any code using a Bird should work with a Penguin without breaking, even if Penguins can't fly.",
                tags: ["solid", "liskov", "inheritance", "substitution", "design-principles"]
            },
            {
                q: "What is the difference between abstract classes and interfaces?",
                a: "Abstract classes can have implemented methods, constructors, and state variables, supporting single inheritance. Interfaces define pure contracts with no implementation, supporting multiple inheritance. Abstract classes share code among closely related classes, while interfaces define behavior across unrelated classes. Choose abstract classes for 'is-a' relationships with shared code, interfaces for 'can-do' capabilities.",
                r: "Abstract Vehicle class with shared engine logic vs Flyable interface for planes, birds, drones.",
                tags: ["abstract-class", "interface", "inheritance", "design", "contracts"]
            },
            {
                q: "What is the Single Responsibility Principle (SRP)?",
                a: "SRP states that a class should have only one reason to change - meaning it should have only one primary responsibility or purpose. This principle helps create more maintainable, understandable, and robust code. When a class has multiple responsibilities, changes to one responsibility can unexpectedly affect others, making the code fragile and harder to maintain.",
                r: "A User class should handle user data, not email sending and database logging too.",
                tags: ["solid", "single-responsibility", "design-principles", "maintainability", "class-design"]
            },
            {
                q: "What is the Open/Closed Principle (OCP)?",
                a: "OCP states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code. Achieve this through abstraction, interfaces, and polymorphism. This principle reduces the risk of introducing bugs when extending functionality and makes code more maintainable.",
                r: "Add new payment methods by creating new classes, not modifying existing payment processor code.",
                tags: ["solid", "open-closed", "design-principles", "extensibility", "maintenance"]
            },
            {
                q: "What is the Interface Segregation Principle (ISP)?",
                a: "ISP states that clients should not be forced to depend on interfaces they don't use. Instead of large, monolithic interfaces, create smaller, specific interfaces for different client needs. This prevents 'interface pollution' where classes must implement methods they don't need. ISP leads to more focused, maintainable code and reduces the impact of changes.",
                r: "Separate Print and Scan interfaces instead of one MultiFunctionDevice interface.",
                tags: ["solid", "interface-segregation", "design-principles", "interfaces", "client-focused"]
            },
            {
                q: "What is the Dependency Inversion Principle (DIP)?",
                a: "DIP states that high-level modules should not depend on low-level modules; both should depend on abstractions. Also, abstractions should not depend on details; details should depend on abstractions. This principle decouples components, making systems more flexible and testable. It's the foundation for dependency injection and inversion of control containers.",
                r: "Business logic depends on Logger interface, not concrete FileLogger or DatabaseLogger classes.",
                tags: ["solid", "dependency-inversion", "design-principles", "dependency-injection", "decoupling"]
            },
            {
                q: "What is dependency injection and how does it work?",
                a: "Dependency injection is a technique where dependencies are provided to an object from external sources rather than created internally. It implements the Dependency Inversion Principle by making high-level modules depend on abstractions. DI can be done through constructor injection, setter injection, or interface injection, improving testability and flexibility.",
                r: "Passing a DatabaseService into UserService constructor instead of creating it inside.",
                tags: ["dependency-injection", "di", "design-patterns", "inversion-of-control", "testability"]
            },
            {
                q: "What is the difference between aggregation and composition?",
                a: "Both are 'has-a' relationships, but with different lifecycles. In composition, the child cannot exist without the parent (strong ownership). In aggregation, the child can exist independently of the parent (weak ownership). Composition implies destruction of parts when the whole is destroyed; aggregation does not.",
                r: "Composition: Engine destroyed when Car destroyed. Aggregation: Department exists even if University closes.",
                tags: ["aggregation", "composition", "relationships", "uml", "design-patterns"]
            },
            {
                q: "What is the Factory Method pattern in OOP?",
                a: "Factory Method is a creational pattern that defines an interface for creating objects but lets subclasses decide which class to instantiate. It allows a class to delegate instantiation to subclasses, promoting loose coupling and making code more flexible for adding new types without modifying existing code.",
                r: "AnimalFactory.createAnimal('dog') returns Dog object without client knowing Dog class.",
                tags: ["factory-pattern", "creational-patterns", "design-patterns", "encapsulation", "polymorphism"]
            },
            {
                q: "What is the Observer pattern and when should you use it?",
                a: "Observer is a behavioral pattern where one object (subject) maintains a list of dependents (observers) and notifies them of state changes. Use it when you need one-to-many dependency between objects so that when one changes state, all dependents are updated automatically without tight coupling.",
                r: "UI components update when data model changes, or event handling systems.",
                tags: ["observer-pattern", "behavioral-patterns", "design-patterns", "events", "loose-coupling"]
            },
            {
                q: "What is the Strategy pattern in OOP?",
                a: "Strategy is a behavioral pattern that defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets you select algorithms at runtime without changing the clients that use them. This pattern is useful when you have multiple ways to do something and want to choose between them dynamically.",
                r: "PaymentProcessor uses different payment strategies (CreditCard, PayPal, Bitcoin) interchangeably.",
                tags: ["strategy-pattern", "behavioral-patterns", "design-patterns", "algorithms", "runtime-selection"]
            },
            {
                q: "What is the Singleton pattern and when should you use it?",
                a: "Singleton is a creational pattern that ensures a class has only one instance and provides global access to it. Use it when exactly one object is needed to coordinate actions across the system, like database connections, logging, or configuration managers. Be cautious as it can make testing difficult and hide dependencies.",
                r: "DatabaseConnection.getInstance() returns the same connection object throughout the application.",
                tags: ["singleton-pattern", "creational-patterns", "design-patterns", "global-state", "instance-control"]
            },
            {
                q: "What is the difference between tight coupling and loose coupling?",
                a: "Tight coupling means classes are highly dependent on each other's implementation details, making changes difficult and error-prone. Loose coupling means classes depend on abstractions rather than concrete implementations, making the system more flexible, testable, and maintainable. OOP principles like DIP and dependency injection promote loose coupling.",
                r: "Tight: OrderService directly creates PaymentProcessor. Loose: OrderService uses IPaymentProcessor interface.",
                tags: ["coupling", "loose-coupling", "tight-coupling", "design-principles", "dependencies"]
            },
            {
                q: "What is the Template Method pattern in OOP?",
                a: "Template Method is a behavioral pattern that defines the skeleton of an algorithm in a base class but lets subclasses override specific steps. It allows subclasses to redefine parts of an algorithm without changing its structure. Use it when you have multiple algorithms with similar overall flow but different implementation details.",
                r: "DataProcessor defines process() skeleton with read(), validate(), transform(), save() steps that subclasses implement.",
                tags: ["template-method-pattern", "behavioral-patterns", "design-patterns", "algorithms", "code-reuse"]
            },
            {
                q: "What is the difference between association and dependency?",
                a: "Association is a structural relationship between two classes where one uses the other as a field or parameter. Dependency is a weaker relationship where one class temporarily uses another in a method. Association implies longer-term relationship and often means one class holds a reference to another. Dependency is typically short-term and method-level.",
                r: "Association: Car has Engine field. Dependency: OrderService uses TaxCalculator in calculateTotal() method.",
                tags: ["association", "dependency", "relationships", "uml", "design-patterns"]
            },
            {
                q: "What is the Builder pattern and when should you use it?",
                a: "Builder is a creational pattern that separates the construction of a complex object from its representation. Use it when an object has many optional parameters or complex construction logic. It provides a fluent interface for building objects step-by-step, making code more readable and avoiding telescoping constructors.",
                r: "UserBuilder.setName('John').setAge(25).setEmail('john@email').build() creates User object.",
                tags: ["builder-pattern", "creational-patterns", "design-patterns", "fluent-interface", "complex-objects"]
            },
            {
                q: "What is the Adapter pattern and when should you use it?",
                a: "Adapter is a structural pattern that allows incompatible interfaces to work together. It acts as a bridge between two incompatible classes, converting one interface to another. Use it when you need to integrate existing code with new systems, or when third-party libraries have incompatible interfaces.",
                r: "LegacyPrinterAdapter makes old printer work with new printing system without changing printer code.",
                tags: ["adapter-pattern", "structural-patterns", "design-patterns", "interface-compatibility", "integration"]
            },
            {
                q: "What is the Command pattern and when should you use it?",
                a: "Command is a behavioral pattern that encapsulates a request as an object, allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations. Use it for implementing undo/redo, macro operations, or when you need to decouple the object that invokes an operation from the one that knows how to perform it.",
                r: "Text editor's undo system stores each edit as a Command object that can be executed or undone.",
                tags: ["command-pattern", "behavioral-patterns", "design-patterns", "undo-redo", "encapsulation"]
            },
            {
                q: "What is the Decorator pattern and when should you use it?",
                a: "Decorator is a structural pattern that allows you to add new functionality to objects dynamically without altering their structure. It wraps objects to add responsibilities. Use it when you need to extend functionality of objects at runtime, or when subclassing would create too many classes.",
                r: "InputStream -> BufferedInputStream -> CipherInputStream adds buffering and encryption dynamically.",
                tags: ["decorator-pattern", "structural-patterns", "design-patterns", "dynamic-behavior", "wrapping"]
            },
            {
                q: "What is the difference between inheritance and composition in terms of design flexibility?",
                a: "Inheritance creates tight coupling between parent and child classes, making changes to the parent affect all children. Composition creates loose coupling by assembling objects from independent components. Composition provides more flexibility as you can change components at runtime, while inheritance relationships are fixed at compile time. Favor composition over inheritance for better maintainability.",
                r: "Inheritance: Car is-a Vehicle. Composition: Car has-a Engine, has-a Transmission, has-a Wheels.",
                tags: ["inheritance", "composition", "design-flexibility", "coupling", "design-principles"]
            },
            {
                q: "What is the Facade pattern and when should you use it?",
                a: "Facade is a structural pattern that provides a simplified interface to a complex subsystem. It hides complexity by providing a single entry point to multiple subsystems. Use it when you need to simplify a complex system, provide a high-level interface, or decouple clients from subsystem implementation details.",
                r: "ComputerFacade.start() handles CPU, memory, disk, and OS initialization behind one simple method.",
                tags: ["facade-pattern", "structural-patterns", "design-patterns", "simplification", "complexity-hiding"]
            },
            {
                q: "What is the Proxy pattern and when should you use it?",
                a: "Proxy is a structural pattern that provides a surrogate or placeholder for another object to control access to it. Use it for lazy loading, access control, logging, caching, or when you need to add functionality without modifying the original object. The proxy acts as an intermediary that can perform operations before or after forwarding requests to the real object.",
                r: "ImageProxy loads large image only when needed, or SecurityProxy checks permissions before method calls.",
                tags: ["proxy-pattern", "structural-patterns", "design-patterns", "access-control", "lazy-loading"]
            },
            {
                q: "What is the Chain of Responsibility pattern and when should you use it?",
                a: "Chain of Responsibility is a behavioral pattern that passes a request along a chain of handlers until one handles it. Each handler decides whether to process the request or pass it to the next handler. Use it when you want to decouple senders and receivers, allow multiple objects to handle a request, or when you want to avoid hardcoding receiver.",
                r: "Help desk system where Level 1 handles basic issues, Level 2 handles complex issues, Level 3 handles escalations.",
                tags: ["chain-of-responsibility-pattern", "behavioral-patterns", "design-patterns", "request-handling", "decoupling"]
            },
            {
                q: "What is the Iterator pattern and when should you use it?",
                a: "Iterator is a behavioral pattern that provides a way to access elements of an aggregate object sequentially without exposing its underlying representation. Use it when you want to provide multiple ways to traverse an aggregate, simplify the aggregate interface, or when you need uniform traversal across different data structures.",
                r: "ListIterator, TreeIterator, and HashMapIterator all provide hasNext() and next() methods for consistent traversal.",
                tags: ["iterator-pattern", "behavioral-patterns", "design-patterns", "traversal", "encapsulation"]
            },
            {
                q: "What is the difference between abstract factory and factory method patterns?",
                a: "Factory Method defines an interface for creating one product, letting subclasses decide which class to instantiate. Abstract Factory provides an interface for creating families of related products without specifying their concrete classes. Use Factory Method for single product creation, Abstract Factory for multiple related products that must work together.",
                r: "Factory Method: AnimalFactory.createAnimal(). Abstract Factory: GUIFactory.createButton() + createWindow().",
                tags: ["factory-pattern", "abstract-factory-pattern", "creational-patterns", "design-patterns", "object-creation"]
            },
            {
                q: "What is the difference between composition and aggregation in UML relationships?",
                a: "In UML, composition is shown with a filled diamond and represents strong ownership where the child cannot exist without the parent. Aggregation is shown with an empty diamond and represents weak ownership where the child can exist independently. Composition implies lifecycle dependency, aggregation does not.",
                r: "Composition: House contains Rooms (rooms destroyed when house destroyed). Aggregation: Department has Employees (employees exist without department).",
                tags: ["composition", "aggregation", "uml", "relationships", "lifecycle"]
            },
            {
                q: "What is the Mediator pattern and when should you use it?",
                a: "Mediator is a behavioral pattern that defines an object that centralizes communication between objects in a system. It promotes loose coupling by preventing objects from referring to each other directly. Use it when you have many objects that need to communicate in complex ways, or when you want to avoid tight coupling between interacting objects.",
                r: "ChatRoom mediator handles messages between User objects instead of users communicating directly.",
                tags: ["mediator-pattern", "behavioral-patterns", "design-patterns", "communication", "loose-coupling"]
            },
            {
                q: "What is the Memento pattern and when should you use it?",
                a: "Memento is a behavioral pattern that captures and externalizes an object's internal state without violating encapsulation, allowing the object to be restored to this state later. Use it for implementing undo/redo, save/load game states, or when you need to checkpoint and rollback object state without exposing internal implementation.",
                r: "Text editor saves Memento objects for each change to enable undo functionality.",
                tags: ["memento-pattern", "behavioral-patterns", "design-patterns", "state-preservation", "undo-redo"]
            },
            {
                q: "What is the State pattern and when should you use it?",
                a: "State is a behavioral pattern that allows an object to change its behavior when its internal state changes. The object will appear to change its class. Use it when an object's behavior depends on its state and it must change behavior at runtime depending on that state, or when you have large conditional statements that switch based on object state.",
                r: "Order object changes behavior based on its state: Pending, Processing, Shipped, Delivered.",
                tags: ["state-pattern", "behavioral-patterns", "design-patterns", "state-machine", "behavior-change"]
            },
            {
                q: "What is the Visitor pattern and when should you use it?",
                a: "Visitor is a behavioral pattern that lets you add new operations to an object structure without modifying the classes of the elements on which it operates. It separates algorithms from the object structure. Use it when you need to perform many different and unrelated operations on an object structure, or when you want to add operations without changing object classes.",
                r: "DocumentVisitor can calculate word count, extract links, or format content without changing Document class.",
                tags: ["visitor-pattern", "behavioral-patterns", "design-patterns", "operations", "extensibility"]
            },
            {
                q: "What is the difference between a class diagram and a sequence diagram in UML?",
                a: "Class diagrams show static structure - classes, attributes, methods, and relationships between classes. They model the architecture and design of a system. Sequence diagrams show dynamic behavior - interactions between objects over time, method calls, and message flow. They model runtime scenarios and use cases. Class diagrams are for 'what exists', sequence diagrams are for 'how they interact'.",
                r: "Class diagram: User, Order, Product classes with relationships. Sequence diagram: User creates Order, Order checks Product availability.",
                tags: ["uml", "class-diagram", "sequence-diagram", "modeling", "design-documentation"]
            },
            {
                q: "What is the difference between cohesion and coupling in software design?",
                a: "Cohesion measures how well elements within a module belong together - high cohesion means elements are strongly related and focused on a single task. Coupling measures interdependence between modules - low coupling means modules are independent and have minimal dependencies. Good design has high cohesion (focused modules) and low coupling (independent modules).",
                r: "High cohesion: EmailValidator only validates emails. Low coupling: EmailService doesn't depend on DatabaseService.",
                tags: ["cohesion", "coupling", "design-quality", "modularity", "software-metrics"]
            },
            {
                q: "What is the difference between an abstract class and a concrete class?",
                a: "Abstract classes cannot be instantiated and may contain abstract methods (methods without implementation) that must be implemented by subclasses. They can also have concrete methods and state. Concrete classes can be instantiated and provide implementations for all methods. Abstract classes define common interfaces and partial implementations for inheritance hierarchies.",
                r: "Abstract: Shape with draw() method. Concrete: Circle, Square classes that implement draw().",
                tags: ["abstract-class", "concrete-class", "inheritance", "polymorphism", "instantiation"]
            },
            {
                q: "What is the difference between multiple inheritance and multilevel inheritance?",
                a: "Multiple inheritance allows a class to inherit from multiple parent classes simultaneously, combining features from all parents. Multilevel inheritance creates a chain of inheritance where a class inherits from a parent, which inherits from another parent. Multiple inheritance can lead to complexity and the diamond problem, while multilevel inheritance creates deeper hierarchies.",
                r: "Multiple: FlyingFish inherits from Fish + Bird. Multilevel: GrandParent -> Parent -> Child.",
                tags: ["inheritance", "multiple-inheritance", "multilevel-inheritance", "hierarchy", "design-complexity"]
            },
            {
                q: "What is the difference between an interface and an abstract class in terms of multiple inheritance?",
                a: "Interfaces support multiple inheritance naturally - a class can implement multiple interfaces without conflicts. Abstract classes typically don't support multiple inheritance in many languages (like Java) due to the diamond problem and implementation conflicts. Interfaces define pure contracts, while abstract classes provide partial implementations, making interfaces safer for multiple inheritance.",
                r: "A class can implement Serializable, Cloneable, Comparable interfaces but usually extends only one abstract class.",
                tags: ["interface", "abstract-class", "multiple-inheritance", "contracts", "design-patterns"]
            },
            {
                q: "What are Python lists, tuples, dictionaries, and sets?",
                a: "Lists are ordered, mutable sequences. Tuples are ordered, immutable sequences. Dictionaries are key-value mappings (mutable). Sets are unordered collections of unique elements. These built-in data structures cover most programming needs without requiring custom implementations, unlike C where you'd implement these manually.",
                r: "Use lists for ordered data you'll modify, tuples for fixed collections, dicts for lookups, sets for uniqueness.",
                tags: ["python", "data-structures", "built-ins"]
            },
            {
                q: "What is the difference between static and dynamic binding in OOP?",
                a: "Static binding (early binding) resolves method calls at compile time based on the reference type. Dynamic binding (late binding) resolves method calls at runtime based on the actual object type. Static binding is used for private, final, and static methods. Dynamic binding enables polymorphism and runtime method resolution.",
                r: "Static: compile-time method resolution. Dynamic: runtime polymorphic method calls.",
                tags: ["binding", "static-binding", "dynamic-binding", "polymorphism", "runtime", "compile-time"]
            },
            {
                q: "What is the difference between a constructor and a method in OOP?",
                a: "Constructors are special methods used to initialize objects when they're created. They have the same name as the class and no return type. Methods are regular functions that perform operations on objects. Constructors are called automatically during object creation, while methods must be called explicitly. Constructors set up initial state, methods define behavior.",
                r: "Constructor: new Person('John') initializes object. Method: person.getName() retrieves data.",
                tags: ["constructor", "method", "initialization", "object-creation", "instantiation"]
            },
            {
                q: "What is the difference between shallow copy and deep copy in OOP?",
                a: "Shallow copy copies the object's fields but not the objects they reference - both copies share the same nested objects. Deep copy creates copies of all nested objects recursively. Shallow copy is faster but can cause unintended side effects when modifying nested objects. Deep copy is safer but more expensive.",
                r: "Shallow: two lists pointing to same items. Deep: two independent lists with duplicate items.",
                tags: ["copying", "memory", "object-cloning", "reference-types"]
            },
            {
                q: "What is the difference between static and instance members in OOP?",
                a: "Static members belong to the class itself and are shared among all instances. Instance members belong to individual objects. Static members can be accessed without creating an object, while instance members require object creation. Static members are useful for shared data and utility methods, instance members for object-specific state and behavior.",
                r: "Static: Math.PI (shared constant). Instance: person.name (individual property).",
                tags: ["static-members", "instance-members", "class-level", "object-level", "shared-state"]
            },
            {
                q: "What is the difference between method chaining and method cascading in OOP?",
                a: "Method chaining calls multiple methods on the same object in a single statement, with each method returning the object itself. Method cascading calls multiple methods on the same object without repeating the object reference. Both improve code readability and reduce temporary variables. Chaining is more common in fluent APIs.",
                r: "Chaining: builder.setTitle('Test').setContent('Hello').show(). Cascading: object.setTitle(); setContent(); show();",
                tags: ["method-chaining", "method-cascading", "fluent-interface", "code-style", "api-design"]
            },
            {
                q: "What is Python used in data science and machine learning?",
                a: "Python dominates data science through NumPy (numerical computing), pandas (data manipulation), matplotlib/seaborn (visualization), and scikit-learn (ML algorithms). Deep learning frameworks like TensorFlow and PyTorch are Python-first. Jupyter notebooks provide interactive development, making Python ideal for data exploration and model development.",
                r: "Most data scientists and ML engineers use Python as their primary language for analysis and modeling.",
                tags: ["python", "data-science", "machine-learning"]
            },
            {
                q: "What is the difference between value types and reference types in OOP?",
                a: "Value types store data directly and are copied when assigned, creating independent copies. Reference types store references to objects on the heap, so multiple variables can reference the same object. Value types include primitives like int, bool, char. Reference types include classes, arrays, strings. Understanding this difference is crucial for memory management and avoiding unexpected side effects.",
                r: "Value: int a = 5; int b = a; (b gets copy). Reference: Person p1 = new Person(); Person p2 = p1; (p2 points to same object).",
                tags: ["value-types", "reference-types", "memory", "stack", "heap", "assignment"]
            },
            {
                q: "What is the difference between early binding and late binding in OOP?",
                a: "Early binding (static binding) resolves method calls at compile time, providing better performance but less flexibility. Late binding (dynamic binding) resolves method calls at runtime, enabling polymorphism and more flexible code. Early binding is used for static methods, final methods, and when the exact method to call is known. Late binding enables runtime method selection based on actual object types.",
                r: "Early binding: faster, compile-time. Late binding: slower, enables polymorphism and flexibility.",
                tags: ["early-binding", "late-binding", "static-binding", "dynamic-binding", "polymorphism", "performance"]
            },
            {
                q: "What is the difference between method overloading and method overriding in OOP?",
                a: "Method overloading defines multiple methods with the same name but different parameters in the same class. Method overriding provides a new implementation for a method in a subclass that already exists in the parent class. Overloading is compile-time polymorphism, overriding is runtime polymorphism. Overloading increases code readability, overriding enables specialized behavior in subclasses.",
                r: "Overloading: same method name, different parameters. Overriding: subclass replaces parent method implementation.",
                tags: ["method-overloading", "method-overriding", "polymorphism", "inheritance", "compile-time", "runtime"]
            },
            {
                q: "What is the difference between abstraction and encapsulation in OOP?",
                a: "Abstraction hides complexity by showing only essential features and hiding implementation details. Encapsulation bundles data and methods together into a single unit and restricts access to internal state. Abstraction is about what an object does, encapsulation is about how it does it. Abstraction reduces complexity, encapsulation protects data integrity.",
                r: "Abstraction: hiding implementation details. Encapsulation: bundling data and methods together.",
                tags: ["abstraction", "encapsulation", "data-hiding", "complexity", "design-principles"]
            },
            {
                tags: ["python", "pitfalls", "best-practices"]
            },
            {
                q: "What is the difference between a class and an object in OOP?",
                a: "A class is a blueprint or template that defines properties and behaviors for objects. An object is an instance of a class with actual data and state. Classes define structure, objects are concrete entities. Classes are static definitions, objects are dynamic instances. You create multiple objects from one class, each with its own state.",
                r: "Class: blueprint for creating objects. Object: instance of a class with actual data.",
                tags: ["class", "object", "instance", "blueprint", "template", "oop-basics"]
            },
            {
                q: "What is the difference between access modifiers public, private, and protected?",
                a: "Public allows access from anywhere, private restricts access to within the same class only, and protected allows access within the same class and subclasses. Public provides maximum accessibility, private provides maximum encapsulation, protected balances accessibility with inheritance needs. These modifiers implement encapsulation and control data access.",
                r: "Public: accessible everywhere. Private: only within class. Protected: class + subclasses.",
                tags: ["access-modifiers", "public", "private", "protected", "encapsulation", "visibility"]
            },
            {
                q: "What is the difference between a base class and a derived class?",
                a: "A base class (parent class) is the class being inherited from, providing common attributes and methods. A derived class (child class) inherits from the base class and can extend or override its functionality. Base classes define common behavior, derived classes provide specialized behavior. This enables code reuse and hierarchical relationships.",
                r: "Base class: parent class being inherited. Derived class: child class that inherits.",
                tags: ["base-class", "derived-class", "inheritance", "parent-class", "child-class", "hierarchy"]
            },
            {
                q: "What is the difference between method signature and method body?",
                a: "Method signature defines the method's name, parameters, and return type - it's the interface. Method body contains the actual implementation code - it's the logic. Signature is for identification and calling, body is for execution. Signatures must be unique for overloading, bodies can vary while keeping same signature.",
                r: "Signature: method name + parameters. Body: actual implementation code.",
                tags: ["method-signature", "method-body", "interface", "implementation", "overloading"]
            },
            {
                q: "What is the difference between runtime polymorphism and compile-time polymorphism?",
                a: "Compile-time polymorphism (static) is resolved during compilation via method overloading and operator overloading. Runtime polymorphism (dynamic) is resolved during execution via method overriding and virtual functions. Compile-time is faster but less flexible, runtime is slower but enables true polymorphic behavior. Both achieve polymorphism through different mechanisms.",
                r: "Compile-time: overloading (fast). Runtime: overriding (flexible).",
                tags: ["runtime-polymorphism", "compile-time-polymorphism", "overloading", "overriding", "dynamic-binding"]
            },
            {
                q: "What is the difference between object state and object behavior?",
                a: "Object state refers to the data or attributes stored in an object at any given time. Object behavior refers to the methods or operations an object can perform. State represents what an object knows, behavior represents what an object does. State changes over time through method calls, behavior remains consistent. State is data, behavior is functionality.",
                r: "State: object's data/attributes. Behavior: object's methods/operations.",
                tags: ["object-state", "object-behavior", "attributes", "methods", "data", "functionality"]
            },
            {
                q: "What is the difference between object identity and object equality?",
                a: "Object identity refers to whether two references point to the exact same object in memory (== operator). Object equality refers to whether two objects have the same content or value (.equals() method). Identity is about memory location, equality is about logical equivalence. Two objects can be equal but have different identities.",
                r: "Identity: same memory location. Equality: same content/value.",
                tags: ["object-identity", "object-equality", "equals", "hashcode", "memory", "comparison"]
            },
            {
                q: "What is the difference between object collaboration and object composition?",
                a: "Object collaboration refers to objects working together by sending messages and calling methods. Object composition is a specific relationship where one object contains or owns other objects. Collaboration is about interaction, composition is about ownership. All composition involves collaboration, but not all collaboration involves composition.",
                r: "Collaboration: objects working together. Composition: object contains other objects.",
                tags: ["object-collaboration", "object-composition", "interaction", "ownership", "has-a-relationship"]
            },
            {
                q: "What is the difference between object lifecycle and object scope?",
                a: "Object lifecycle refers to the phases from creation to destruction: instantiation, usage, and garbage collection. Object scope refers to where and when an object can be accessed in the program. Lifecycle is about time duration, scope is about accessibility. Objects can have different scopes (local, instance, static) but all follow the same lifecycle pattern.",
                r: "Lifecycle: creation to destruction. Scope: where object is accessible.",
                tags: ["object-lifecycle", "object-scope", "creation", "destruction", "accessibility", "garbage-collection"]
            },
            {
                q: "What is the difference between object responsibility and object capability?",
                a: "Object responsibility refers to what an object should do according to its design and Single Responsibility Principle. Object capability refers to what an object can do based on its available methods and properties. Responsibility is about design intent, capability is about implementation. Objects should have focused responsibilities but broad capabilities through collaboration.",
                r: "Responsibility: what object should do. Capability: what object can do.",
                tags: ["object-responsibility", "object-capability", "srp", "design-intent", "implementation"]
            },
            {
                q: "What is the difference between object interface and object implementation?",
                a: "Object interface defines what operations an object provides (public methods and properties). Object implementation contains the actual code that performs those operations. Interface is the contract, implementation is the fulfillment. Interface focuses on 'what', implementation focuses on 'how'. Good design separates interface from implementation.",
                r: "Interface: what object does. Implementation: how object does it.",
                tags: ["object-interface", "object-implementation", "contract", "abstraction", "encapsulation"]
            },
            {
                q: "What is the difference between object messaging and object invocation?",
                a: "Object messaging refers to the conceptual communication between objects where one object sends a message to another. Object invocation is the actual mechanism of calling a method on an object. Messaging is about the design pattern, invocation is about the technical implementation. Messaging emphasizes loose coupling, invocation is the concrete action.",
                r: "Messaging: conceptual communication. Invocation: actual method call.",
                tags: ["object-messaging", "object-invocation", "communication", "method-call", "loose-coupling"]
            },
            {
                q: "What is the difference between object persistence and object serialization?",
                a: "Object persistence refers to keeping objects alive beyond program execution through storage in databases or files. Object serialization is the process of converting objects to a stream of bytes for storage or transmission. Persistence is about long-term storage, serialization is about data format conversion. Serialization is often used to achieve persistence.",
                r: "Persistence: keeping objects alive. Serialization: converting to bytes.",
                tags: ["object-persistence", "object-serialization", "storage", "database", "byte-conversion"]
            },
            {
                q: "What is the difference between object cloning and object copying?",
                a: "Object cloning creates an exact duplicate of an object, typically using a clone() method. Object copying can be shallow (copying references) or deep (copying nested objects). Cloning is usually a specific operation, copying is a general concept. Cloning preserves type and state, copying may lose type information in shallow copies.",
                r: "Cloning: exact duplicate. Copying: may be shallow or deep.",
                tags: ["object-cloning", "object-copying", "duplicate", "shallow-copy", "deep-copy"]
            },
            {
                q: "What is the difference between object pooling and object caching?",
                a: "Object pooling maintains a set of reusable objects to avoid frequent creation/destruction. Object caching stores frequently accessed objects for quick retrieval. Pooling manages object lifecycle, caching manages object accessibility. Pooling is for performance optimization, caching is for data access optimization. Both improve performance but solve different problems.",
                r: "Pooling: reusable objects. Caching: quick object retrieval.",
                tags: ["object-pooling", "object-caching", "performance", "optimization", "reuse"]
            },
            {
                q: "What is the difference between object graph and object hierarchy?",
                a: "Object graph represents the network of interconnected objects through references, showing relationships. Object hierarchy represents the inheritance structure showing parent-child relationships. Graph is about runtime connections, hierarchy is about design relationships. Graph can be complex and cyclical, hierarchy is typically tree-like and acyclic.",
                r: "Graph: network of references. Hierarchy: inheritance structure.",
                tags: ["object-graph", "object-hierarchy", "references", "inheritance", "relationships"]
            },
            {
                q: "What is the difference between object identity and object mutability?",
                a: "Object identity refers to whether two references point to the same object. Object mutability refers to whether an object's state can be changed after creation. Identity is about reference equality, mutability is about state changeability. Immutable objects maintain identity but can't change state, mutable objects can change state while maintaining identity.",
                r: "Identity: reference equality. Mutability: state changeability.",
                tags: ["object-identity", "object-mutability", "immutable", "mutable", "state-change"]
            },
            {
                q: "What is the difference between object initialization and object instantiation?",
                a: "Object instantiation is the process of creating an object instance using 'new' or similar mechanisms. Object initialization is the process of setting up the object's initial state through constructors or initialization methods. Instantiation allocates memory, initialization sets values. Instantiation happens first, then initialization completes object setup.",
                r: "Instantiation: creating object. Initialization: setting up object state.",
                tags: ["object-initialization", "object-instantiation", "constructor", "memory-allocation", "setup"]
            },
            {
                q: "What is the difference between object delegation and object inheritance?",
                a: "Object inheritance creates 'is-a' relationships where subclasses inherit from superclasses. Object delegation creates 'has-a' relationships where objects forward requests to other objects. Inheritance is static at compile time, delegation is dynamic at runtime. Inheritance creates tight coupling, delegation creates loose coupling. Delegation is more flexible than inheritance.",
                r: "Inheritance: is-a relationship. Delegation: has-a relationship.",
                tags: ["object-delegation", "object-inheritance", "is-a", "has-a", "composition", "flexibility"]
            },
            {
                q: "What is the difference between object coupling and object cohesion?",
                a: "Object cohesion measures how well elements within an object belong together. Object coupling measures how dependent objects are on each other. High cohesion means focused responsibilities, low coupling means independence. Good design has high cohesion and low coupling. Cohesion is internal quality, coupling is external relationship.",
                r: "Cohesion: internal focus. Coupling: external dependency.",
                tags: ["object-coupling", "object-cohesion", "design-quality", "independence", "focus"]
            },
            {
                q: "What is the difference between object granularity and object abstraction?",
                a: "Object granularity refers to the size and scope of an object's responsibilities. Object abstraction refers to hiding implementation details while showing essential features. Granularity is about how much an object does, abstraction is about how much it reveals. Fine-grained objects have specific responsibilities, coarse-grained objects have broad responsibilities.",
                r: "Granularity: object size/scope. Abstraction: hiding details.",
                tags: ["object-granularity", "object-abstraction", "scope", "size", "responsibility"]
            },
            {
                q: "What is the difference between object autonomy and object collaboration?",
                a: "Object autonomy refers to an object's ability to operate independently with self-contained logic and state. Object collaboration refers to objects working together to achieve common goals. Autonomy emphasizes independence, collaboration emphasizes cooperation. Autonomous objects make decisions locally, collaborative objects coordinate with others.",
                r: "Autonomy: independent operation. Collaboration: working together.",
                tags: ["object-autonomy", "object-collaboration", "independence", "cooperation", "self-contained"]
            },
            {
                q: "What is the difference between interface and abstract class in OOP?",
                a: "An interface defines a contract that must be implemented by any class that implements it. An abstract class provides a partial implementation that can be shared by subclasses. Interfaces are used for defining a common set of methods that must be implemented, while abstract classes are used for providing a basic implementation that can be extended.",
                r: "Interface: defines a contract. Abstract class: provides a partial implementation.",
                tags: ["interface", "abstract-class", "oop", "contract", "implementation"]
            },
            {
                q: "What is the difference between object encapsulation and object abstraction?",
                a: "Object encapsulation bundles data and methods together and restricts access to internal state. Object abstraction hides implementation details while showing essential features. Encapsulation is about bundling and protection, abstraction is about hiding complexity. Encapsulation is the mechanism, abstraction is the principle.",
                r: "Encapsulation: bundling data + methods. Abstraction: hiding implementation details.",
                tags: ["object-encapsulation", "object-abstraction", "bundling", "hiding", "protection"]
            },
            {
                q: "What is the difference between inheritance and polymorphism in OOP?",
                a: "Inheritance is a mechanism where a subclass inherits properties and methods from a parent class. Polymorphism is the ability of an object to take on multiple forms, depending on the context. Inheritance is about creating a new class based on an existing one, while polymorphism is about objects behaving differently in different situations.",
                r: "Inheritance: creating a new class from an existing one. Polymorphism: objects behaving differently.",
                tags: ["inheritance", "polymorphism", "oop", "subclass", "parent-class"]
            },
            {
                q: "What is the difference between composition and aggregation in OOP?",
                a: "Composition is a strong 'part-of' relationship where the child cannot exist without the parent. Aggregation is a weak 'has-a' relationship where the child can exist independently. Composition implies ownership and lifecycle dependency, aggregation implies loose association. Composition destroys child when parent is destroyed.",
                r: "Composition: strong ownership. Aggregation: loose association.",
                tags: ["composition", "aggregation", "has-a", "part-of", "ownership", "lifecycle"]
            },
            {
                q: "What is the difference between association and dependency in OOP?",
                a: "Association is a structural relationship between objects where one object uses another. Dependency is a weaker relationship where one object requires another to function. Association implies ongoing relationship, dependency implies temporary usage. Association can be bidirectional, dependency is typically unidirectional.",
                r: "Association: structural relationship. Dependency: usage requirement.",
                tags: ["association", "dependency", "relationship", "usage", "structure"]
            },
            {
                q: "What is the difference between SOLID principles and design patterns?",
                a: "SOLID principles are fundamental guidelines for writing maintainable, scalable code (SRP, OCP, LSP, ISP, DIP). Design patterns are specific solutions to common problems (Singleton, Factory, Observer, etc.). SOLID provides principles, patterns provide implementations. SOLID is about 'what' to avoid, patterns are about 'how' to solve.",
                r: "SOLID: design principles. Patterns: specific solutions.",
                tags: ["solid-principles", "design-patterns", "srp", "ocp", "lsp", "isp", "dip"]
            },
            {
                q: "What is the difference between tight coupling and loose coupling in OOP?",
                a: "Tight coupling means classes are highly dependent on each other, making changes difficult. Loose coupling means classes have minimal dependencies, making changes easier. Tight coupling creates fragile systems, loose coupling creates flexible systems. Good design aims for loose coupling through interfaces, dependency injection, and abstraction.",
                r: "Tight coupling: high dependency. Loose coupling: low dependency.",
                tags: ["tight-coupling", "loose-coupling", "dependency", "flexibility", "maintainability"]
            },
            {
                q: "What is the difference between high cohesion and low cohesion in OOP?",
                a: "High cohesion means elements within a class are closely related and focused on a single responsibility. Low cohesion means elements are unrelated and scattered across multiple responsibilities. High cohesion creates maintainable, understandable classes. Low cohesion creates confusing, hard-to-maintain classes. Good design aims for high cohesion.",
                r: "High cohesion: focused responsibility. Low cohesion: scattered responsibilities.",
                tags: ["high-cohesion", "low-cohesion", "responsibility", "focus", "maintainability"]
            },
            {
                q: "What is the difference between dependency injection and service locator?",
                a: "Dependency injection passes dependencies to objects through constructors or methods. Service locator requires objects to request dependencies from a central registry. DI makes dependencies explicit and testable, service locator hides dependencies and creates tight coupling. DI promotes loose coupling, service locator can become a hidden dependency.",
                r: "DI: dependencies given to object. Service locator: object requests dependencies.",
                tags: ["dependency-injection", "service-locator", "di-container", "ioc", "loose-coupling"]
            },
            {
                q: "What is the difference between inversion of control and dependency injection?",
                a: "Inversion of Control (IoC) is a principle where control flow is inverted compared to procedural programming. Dependency Injection (DI) is a specific implementation of IoC for managing dependencies. IoC is the broader concept, DI is one way to achieve it. IoC includes DI, service locator, and other patterns.",
                r: "IoC: general principle. DI: specific implementation.",
                tags: ["inversion-of-control", "dependency-injection", "ioc", "di", "control-flow"]
            },
            {
                q: "What are CSS preprocessors and why use them?",
                a: "CSS preprocessors like Sass, Less, and Stylus extend CSS with variables, nesting, mixins, functions, and other programming features. They improve maintainability, reduce repetition, and enable more efficient development. Preprocessors compile to standard CSS that browsers understand.",
                r: "Sass is the most popular preprocessor, offering variables, nesting, and mixins.",
                tags: ["css", "preprocessors", "sass", "less", "nesting", "mixins"]
            },
            {
                q: "What are CSS methodology and naming conventions?",
                a: "CSS methodologies like BEM (Block, Element, Modifier), OOCSS (Object-Oriented CSS), and SMACSS provide structured approaches to writing maintainable CSS. They establish naming conventions and organizational patterns that reduce specificity conflicts, improve scalability, and make codebases easier to understand and modify.",
                r: "BEM: .block__element--modifier for clear, predictable naming.",
                tags: ["css", "methodology", "bem", "oocss", "naming-conventions", "architecture"]
            },
            {
                q: "What is CSS-in-JS and how does it differ from traditional CSS?",
                a: "CSS-in-JS writes CSS directly in JavaScript files using libraries like styled-components, Emotion, or CSS Modules. It offers scoped styles, dynamic styling based on props, and better JavaScript integration. Traditional CSS uses separate .css files with global scope. CSS-in-JS is popular in React ecosystems.",
                r: "Use CSS-in-JS for component-based frameworks, traditional CSS for static sites.",
                tags: ["css", "css-in-js", "styled-components", "emotion", "javascript", "components"]
            },
            {
                q: "What are CSS performance optimization techniques?",
                a: "CSS optimization includes minimizing file size, reducing selectors, avoiding expensive properties, using efficient animations (transform/opacity), optimizing critical CSS for above-the-fold content, and leveraging browser caching. Performance impacts page load speed and user experience, especially on mobile devices.",
                r: "Optimize critical CSS first, use transform/opacity for animations, minimize selector complexity.",
                tags: ["css", "performance", "optimization", "critical-css", "loading"]
            },
            {
                tags: ["css", "debugging", "devtools", "troubleshooting", "browser-tools"]
            },
            {
                q: "What is JavaScript and how does it enable dynamic web pages?",
                a: "JavaScript is a high-level, interpreted programming language that enables interactive web pages. It runs in browsers, manipulates the DOM, responds to user events, and communicates with servers. JavaScript transforms static HTML into dynamic applications by adding behavior, animations, form validation, and real-time updates.",
                r: "JavaScript makes websites interactive: forms validate, content updates dynamically, and users get immediate feedback.",
                tags: ["javascript", "web-development", "dynamic", "dom", "interactivity"]
            },
            {
                q: "What are the different ECMAScript editions and their key features?",
                a: "ECMAScript (ES) is the JavaScript standard. Key editions: ES5 (2009) added strict mode and array methods; ES6/ES2015 added classes, arrow functions, let/const, promises, modules; ES2016-2022 added async/await, optional chaining, nullish coalescing. Each edition adds features while maintaining backward compatibility.",
                r: "ES6 revolutionized JavaScript with modern syntax; ES2020+ adds quality-of-life improvements.",
                tags: ["javascript", "ecmascript", "es6", "es2020", "standards", "features"]
            },
            {
                q: "What are JavaScript data types and type coercion?",
                a: "JavaScript has primitive types (string, number, boolean, undefined, null, symbol, bigint) and object types. Type coercion automatically converts values between types, which can cause unexpected results. Understanding implicit coercion, explicit conversion, and equality operators (== vs ===) is crucial for writing predictable code.",
                r: "Use === for strict equality to avoid type coercion surprises.",
                tags: ["javascript", "data-types", "coercion", "equality", "type-conversion"]
            },
            {
                q: "What are JavaScript functions, closures, and scope?",
                a: "Functions are reusable blocks of code that can be defined as declarations, expressions, or arrow functions. Closures allow functions to access variables from their outer scope even after the outer function returns. Scope determines variable accessibility (global, function, block scope with let/const).",
                r: "Closures enable powerful patterns like data privacy and function factories.",
                tags: ["javascript", "functions", "closures", "scope", "hoisting"]
            },
            {
                q: "What is the Document Object Model (DOM) and how does JavaScript manipulate it?",
                a: "The DOM is a tree-like representation of HTML elements that JavaScript can query and modify. DOM manipulation includes selecting elements (querySelector, getElementById), changing content (textContent, innerHTML), modifying attributes, creating/removing elements, and handling events. DOM updates trigger browser reflows/repaints.",
                r: "Use querySelector for modern element selection,textContent for safe content updates.",
                tags: ["javascript", "dom", "manipulation", "events", "browser-api"]
            },
            {
                q: "What are JavaScript promises and async programming?",
                a: "Promises represent eventual completion (or failure) of asynchronous operations. They have states (pending, fulfilled, rejected) and methods (then, catch, finally). Async/await syntax makes asynchronous code look synchronous. Promises solve callback hell and enable better error handling for async operations like API calls.",
                r: "Use async/await for readable async code, promises for complex async workflows.",
                tags: ["javascript", "promises", "async", "await", "callbacks", "asynchronous"]
            },
            {
                q: "What are JavaScript modules and import/export?",
                a: "Modules enable code organization and reuse by splitting code into separate files. ES6 modules use import/export syntax. CommonJS (Node.js) uses require/module.exports. Modules have their own scope, prevent global pollution, and enable static analysis for better tooling and tree-shaking.",
                r: "Use ES6 modules for browsers, CommonJS for Node.js projects.",
                tags: ["javascript", "modules", "import", "export", "commonjs", "esm"]
            },
            {
                q: "What are popular JavaScript frameworks and libraries?",
                a: "React (component-based UI library), Vue (progressive framework), Angular (full-featured framework), Svelte (compiler-based). Libraries include jQuery (DOM manipulation), Lodash (utilities), Axios (HTTP client), D3.js (data visualization). Frameworks provide structure and tools for building complex applications.",
                r: "Choose React for component architecture, Vue for gradual adoption, Angular for enterprise apps.",
                tags: ["javascript", "frameworks", "react", "vue", "angular", "libraries"]
            },
            {
                q: "What is Node.js and how does it enable server-side JavaScript?",
                a: "Node.js is a JavaScript runtime built on Chrome's V8 engine. It enables JavaScript outside browsers for server-side development, CLI tools, and desktop apps. Node.js provides APIs for file system, networking, OS interaction, and has a massive npm package ecosystem. It uses an event-driven, non-blocking I/O model.",
                r: "Node.js lets you use JavaScript for backend APIs, build tools, and command-line tools.",
                tags: ["javascript", "nodejs", "backend", "npm", "server-side", "runtime"]
            },
            {
                q: "What are JavaScript build tools and bundlers?",
                a: "Build tools automate development workflows: bundlers (Webpack, Rollup, Vite) combine modules, transpilers (Babel) convert modern JS to compatible versions, minifiers reduce file size. Tools like npm scripts, ESLint, Prettier improve code quality and development experience.",
                r: "Use Vite for fast development, Webpack for complex configurations, Babel for browser compatibility.",
                tags: ["javascript", "build-tools", "webpack", "vite", "babel", "bundler"]
            },
            {
                q: "What is TypeScript and why use it with JavaScript?",
                a: "TypeScript is a superset of JavaScript that adds static typing, interfaces, enums, and better tooling. It compiles to plain JavaScript and provides early error detection, improved IDE support, and better code documentation. TypeScript enhances JavaScript development for large applications and teams.",
                r: "TypeScript catches type errors at compile time, improving code reliability and developer experience.",
                tags: ["javascript", "typescript", "static-typing", "types", "tooling"]
            },
            {
                q: "What are JavaScript testing frameworks and approaches?",
                a: "Testing frameworks include Jest (unit testing), Cypress (E2E testing), Playwright (browser automation), Mocha (flexible testing). Testing approaches: unit tests (isolated functions), integration tests (component interactions), E2E tests (full user workflows). Testing ensures code quality and prevents regressions.",
                r: "Use Jest for unit tests, Cypress for E2E testing, testing libraries for component testing.",
                tags: ["javascript", "testing", "jest", "cypress", "unit-tests", "e2e"]
            },
            {
                q: "What are JavaScript design patterns and best practices?",
                a: "Common patterns include Module (encapsulation), Observer (event handling), Factory (object creation), Singleton (single instance). Best practices: use const/let, avoid global variables, handle errors properly, use meaningful names, write modular code, follow style guides (ESLint, Prettier).",
                r: "Use modules instead of globals, const by default, proper error handling with try/catch.",
                tags: ["javascript", "design-patterns", "best-practices", "module-pattern", "error-handling"]
            },
            {
                q: "What is JavaScript performance optimization?",
                a: "Performance optimization includes minimizing DOM manipulation, using efficient algorithms, debouncing/throttling events, lazy loading, code splitting, caching, and using requestAnimationFrame for animations. Tools like Lighthouse and DevTools help identify bottlenecks. Memory management prevents leaks.",
                r: "Use requestAnimationFrame for smooth animations, debounce input events, lazy load resources.",
                tags: ["javascript", "performance", "optimization", "memory", "animation", "lazy-loading"]
            },
            {
                q: "What are JavaScript security considerations?",
                a: "Security includes preventing XSS attacks (input sanitization, output encoding), avoiding eval() and unsafe dynamic code, implementing Content Security Policy (CSP), using HTTPS, validating inputs, and securing authentication tokens. JavaScript security protects both users and applications.",
                r: "Always sanitize user inputs, use CSP headers, avoid eval() and innerHTML with untrusted content.",
                tags: ["javascript", "security", "xss", "csp", "authentication", "input-validation"]
            },
            {
                q: "What are modern JavaScript APIs and browser capabilities?",
                a: "Modern APIs include Web Components (custom elements), Service Workers (offline support), WebSockets (real-time communication), WebAssembly (high-performance code), Geolocation, LocalStorage, IndexedDB, Canvas/WebGL (graphics), and Web Audio API. These enable powerful web applications without plugins.",
                r: "Service Workers enable PWAs, WebAssembly runs near-native performance, WebSockets handle real-time data.",
                tags: ["javascript", "web-apis", "service-workers", "webassembly", "websockets", "browser-features"]
            },
            {
                q: "What is JavaScript error handling and debugging?",
                a: "Error handling uses try/catch/finally blocks, throw statements, and error objects. Debugging involves browser DevTools (breakpoints, console, debugger statement), source maps for debugging minified code, and logging strategies. Proper error handling improves user experience and debugging.",
                r: "Use try/catch for expected errors, DevTools breakpoints for debugging, console.log for quick inspection.",
                tags: ["javascript", "error-handling", "debugging", "devtools", "try-catch", "source-maps"]
            },
            {
                q: "What is the JavaScript ecosystem and package management?",
                a: "The JavaScript ecosystem includes npm (package manager), yarn (alternative package manager), countless packages for every need, package.json for project configuration, and tools for development, testing, and deployment. The ecosystem enables rapid development by leveraging community packages.",
                r: "npm is the default package manager, use package.json to manage dependencies and scripts.",
                tags: ["javascript", "npm", "package-management", "ecosystem", "dependencies", "package-json"]
            },
            {
                q: "What makes JavaScript so powerful and versatile?",
                a: "JavaScript's power comes from its ubiquity (runs everywhere), dynamic nature, massive ecosystem, single-threaded event loop for non-blocking I/O, first-class functions, and ability to handle both frontend and backend development. It powers everything from simple websites to complex enterprise applications, mobile apps, and IoT devices.",
                r: "JavaScript's 'write once, run everywhere' capability makes it uniquely powerful in modern development.",
                tags: ["javascript", "power", "versatility", "ubiquity", "ecosystem", "full-stack"]
            },
            {
                q: "What are the main JavaScript frontend frameworks and their strengths?",
                a: "React excels in component architecture and ecosystem, Vue offers progressive enhancement and gentle learning curve, Angular provides enterprise-grade structure and TypeScript integration, Svelte compiles away for optimal performance, and Next.js adds server-side rendering to React. Each framework solves different problems and team needs.",
                r: "Choose React for ecosystem, Vue for simplicity, Angular for enterprise, Svelte for performance.",
                tags: ["javascript", "frontend", "frameworks", "react", "vue", "angular", "svelte", "nextjs"]
            },
            {
                q: "How do JavaScript frontend frameworks handle state management?",
                a: "State management approaches include React's useState/useContext, Redux (predictable state container), MobX (observable state), Vuex (Vue's state management), and Angular's services/services pattern. Modern frameworks offer built-in solutions while external libraries handle complex state scenarios across large applications.",
                r: "Use local state for simple cases, Redux/MobX for complex shared state across components.",
                tags: ["javascript", "frontend", "state-management", "redux", "mobx", "vuex", "react-state"]
            },
            {
                q: "What are JavaScript backend frameworks and how do they compare?",
                a: "Express.js is minimal and flexible, NestJS provides TypeScript and structure, Koa focuses on modern async/await, Fastify emphasizes performance, and Meteor offers full-stack isomorphic development. Backend frameworks enable JavaScript to handle APIs, databases, authentication, and server-side logic with the same language as frontend.",
                r: "Express for simplicity, NestJS for enterprise structure, Fastify for performance-critical APIs.",
                tags: ["javascript", "backend", "frameworks", "express", "nestjs", "koa", "fastify", "meteor"]
            },
            {
                q: "How does JavaScript enable full-stack development with a single language?",
                a: "JavaScript's full-stack capability comes from Node.js (backend), browser APIs (frontend), shared libraries (validation, utilities), isomorphic frameworks (Next.js, Nuxt.js), and TypeScript for type safety across the stack. Developers can use the same language, tools, and even share code between frontend and backend, reducing context switching.",
                r: "Full-stack JavaScript means one language for frontend, backend, and even mobile/desktop apps.",
                tags: ["javascript", "full-stack", "isomorphic", "nodejs", "universal", "code-sharing"]
            },
            {
                q: "What are JavaScript framework ecosystems and their tooling?",
                a: "Framework ecosystems include React's Create React App, Next.js, and extensive npm packages; Vue's Vue CLI, Nuxt.js, and official plugins; Angular's Angular CLI and enterprise-grade tooling; and Svelte's SvelteKit. Each ecosystem provides routing, state management, testing, deployment, and development tools.",
                r: "Framework ecosystems provide everything needed for production applications beyond just the core library.",
                tags: ["javascript", "frameworks", "ecosystem", "tooling", "cli", "routing", "testing"]
            },
            {
                q: "How do JavaScript frameworks handle component architecture and reusability?",
                a: "Component approaches include React's functional components with hooks, Vue's single-file components, Angular's TypeScript classes with decorators, and Svelte's compile-time components. All emphasize reusable, composable UI pieces with props/events for communication and lifecycle methods for initialization/cleanup.",
                r: "Components are the building blocks: encapsulated, reusable, and composable UI elements.",
                tags: ["javascript", "frontend", "components", "architecture", "reusability", "composition"]
            },
            {
                q: "What are the performance advantages of JavaScript frameworks and optimization techniques?",
                a: "Modern frameworks optimize through virtual DOM (React, Vue), compile-time optimization (Svelte), code splitting, lazy loading, tree shaking, and server-side rendering. Techniques include memoization, useCallback/useMemo, efficient state updates, and bundle optimization. Performance monitoring tools help identify bottlenecks.",
                r: "Virtual DOM minimizes actual DOM updates, code splitting reduces initial load time.",
                tags: ["javascript", "performance", "optimization", "virtual-dom", "code-splitting", "ssr", "memoization"]
            },
            {
                q: "How has JavaScript evolved from simple scripts to powering the modern web?",
                a: "JavaScript evolved from basic DOM manipulation to complex applications through ES6+ features, powerful frameworks, Node.js backend capabilities, Web APIs, WebAssembly integration, and massive ecosystem growth. It now powers Progressive Web Apps, real-time applications, machine learning in browsers, and cross-platform development.",
                r: "From simple form validation to complex applications: JavaScript's evolution mirrors web's growth.",
                tags: ["javascript", "evolution", "history", "modern-web", "pwa", "webassembly", "cross-platform"]
            },
            {
                q: "What are JavaScript framework patterns for data flow and architecture?",
                a: "Data flow patterns include React's unidirectional data flow, Vue's two-way binding with computed properties, Angular's services and dependency injection, and state management patterns like Redux (actions, reducers, store). Architectural patterns include MVC, MVP, MVVM, and component-based architectures.",
                r: "Unidirectional flow (React) vs two-way binding (Vue) vs dependency injection (Angular).",
                tags: ["javascript", "architecture", "data-flow", "patterns", "mvc", "mvp", "mvvm", "redux"]
            },
            {
                q: "How do JavaScript frameworks handle routing and navigation?",
                a: "Routing solutions include React Router (declarative routing), Vue Router (nested routes), Angular Router (feature-rich routing), and Next.js file-based routing. All support client-side routing, route guards, lazy loading, code splitting, and server-side rendering for optimal performance and SEO.",
                r: "Client-side routing enables SPA navigation without page reloads, improving user experience.",
                tags: ["javascript", "routing", "navigation", "spa", "react-router", "vue-router", "angular-router"]
            },
            {
                q: "What are the testing strategies for JavaScript framework applications?",
                a: "Testing includes unit tests (Jest, Mocha), component tests (React Testing Library, Vue Test Utils), integration tests, and E2E tests (Cypress, Playwright). Framework-specific testing tools and strategies ensure component reliability, user interaction testing, and application stability across different environments.",
                r: "Test components in isolation, integrate them together, then test full user workflows.",
                tags: ["javascript", "testing", "unit-tests", "component-tests", "e2e", "jest", "cypress", "playwright"]
            },
            {
                q: "How do JavaScript frameworks enable cross-platform development?",
                a: "JavaScript enables cross-platform through React Native (mobile), Electron (desktop), Progressive Web Apps (web-to-native), Expo (React Native platform), and frameworks like NativeScript. Write once in JavaScript and deploy to web, iOS, Android, and desktop with platform-specific optimizations.",
                r: "One JavaScript codebase can target web, mobile, and desktop platforms simultaneously.",
                tags: ["javascript", "cross-platform", "react-native", "electron", "pwa", "expo", "nativescript"]
            },
            {
                q: "What are the security considerations in JavaScript framework applications?",
                a: "Security includes XSS prevention (framework sanitization), CSRF protection, secure authentication, content security policy, dependency vulnerability scanning, and secure API communication. Frameworks provide built-in protections but developers must implement proper security practices and keep dependencies updated.",
                r: "Frameworks help with security, but developers must implement proper authentication and input validation.",
                tags: ["javascript", "security", "xss", "csrf", "authentication", "csp", "dependency-security"]
            },
            {
                q: "How do JavaScript frameworks handle real-time data and WebSocket integration?",
                a: "Real-time capabilities include WebSocket APIs, libraries like Socket.IO, GraphQL subscriptions, and framework-specific solutions. Applications can handle live chat, real-time collaboration, live updates, and streaming data. Frameworks provide reactive patterns for updating UI when data changes.",
                r: "WebSockets enable bidirectional real-time communication between client and server.",
                tags: ["javascript", "real-time", "websockets", "socket.io", "graphql", "live-updates", "collaboration"]
            },
            {
                tags: ["javascript", "deployment", "production", "build-tools", "ci-cd", "docker", "serverless", "monitoring"]
            },
            {
                q: "How does JavaScript's type system evolution enhance framework development?",
                a: "TypeScript brings static typing, interfaces, generics, and better tooling to JavaScript. Frameworks increasingly adopt TypeScript for better developer experience, error detection, and code documentation. JSDoc and runtime type checking provide alternatives for pure JavaScript projects.",
                r: "TypeScript catches errors at compile time, improving framework development and maintenance.",
                tags: ["javascript", "typescript", "static-typing", "interfaces", "generics", "tooling", "frameworks"]
            },
            {
                q: "What is React.js and why is it so popular for frontend development?",
                a: "React is a JavaScript library for building user interfaces, created by Facebook. It uses a component-based architecture, virtual DOM for performance, and unidirectional data flow. React's popularity comes from its flexibility, large ecosystem, reusability, strong community support, and ability to handle complex UI state efficiently.",
                r: "React's component model and virtual DOM make it ideal for dynamic, interactive user interfaces.",
                tags: ["react", "frontend", "components", "virtual-dom", "javascript", "ui"]
            },
            {
                q: "What are React components and how do they work?",
                a: "React components are reusable building blocks that return JSX to describe UI. They can be functional (with hooks) or class-based. Components manage their own state, receive props for data, and re-render when state or props change. Components can be composed to create complex UIs.",
                r: "Functional components with hooks are the modern standard; class components are legacy.",
                tags: ["react", "components", "functional-components", "hooks", "props", "state"]
            },
            {
                q: "What are React Hooks and how do they enhance functional components?",
                a: "Hooks are functions that let functional components use state and lifecycle features. Key hooks include useState (state management), useEffect (side effects), useContext (context access), useCallback (memoized callbacks), and useMemo (memoized values). Hooks enable cleaner code and better composition than class components.",
                r: "Hooks revolutionized React by enabling stateful logic in functional components.",
                tags: ["react", "hooks", "usestate", "useeffect", "usecontext", "functional-components"]
            },
            {
                q: "What is the React Virtual DOM and how does it improve performance?",
                a: "The Virtual DOM is a JavaScript representation of the real DOM. React creates a virtual tree, compares it with the previous version, and only updates changed elements (reconciliation). This minimizes expensive DOM operations, making React apps faster than direct DOM manipulation.",
                r: "Virtual DOM updates only what changed, avoiding full page re-renders for better performance.",
                tags: ["react", "virtual-dom", "performance", "reconciliation", "optimization"]
            },
            {
                q: "What are React state management solutions and when to use them?",
                a: "State management includes useState (local state), useContext (global state), Redux (predictable state container), MobX (observable state), and Zustand (minimal state). Use local state for component-specific data, context for app-wide state, and Redux/MobX for complex state sharing across many components.",
                r: "useState for simple state, Context for moderate sharing, Redux for complex app state.",
                tags: ["react", "state-management", "redux", "mobx", "context", "zustand"]
            },
            {
                q: "What is Node.js and how does it enable server-side JavaScript?",
                a: "Node.js is a JavaScript runtime built on Chrome's V8 engine that executes JavaScript outside browsers. It provides APIs for file system, networking, HTTP servers, and OS interaction. Node.js uses an event-driven, non-blocking I/O model, making it efficient for scalable network applications and APIs.",
                r: "Node.js lets you use JavaScript for backend development, APIs, and command-line tools.",
                tags: ["nodejs", "backend", "javascript", "runtime", "server-side", "v8"]
            },
            {
                q: "What is the Node.js event loop and how does it handle concurrency?",
                a: "The Node.js event loop is a single-threaded mechanism that handles asynchronous operations efficiently. It uses a queue system to process events, callbacks, and I/O operations without blocking. This allows Node.js to handle many concurrent connections with high performance, making it ideal for I/O-bound applications.",
                r: "Event loop enables non-blocking I/O: handle thousands of connections on a single thread.",
                tags: ["nodejs", "event-loop", "asynchronous", "concurrency", "non-blocking"]
            },
            {
                q: "What are Node.js modules and how does the module system work?",
                a: "Node.js uses CommonJS modules with require() for importing and module.exports for exporting. Each module has its own scope, preventing global pollution. Node.js also supports ES6 modules with import/export syntax. The module system enables code organization, reusability, and dependency management.",
                r: "Use require() for CommonJS (traditional Node.js), import/export for ES6 modules.",
                tags: ["nodejs", "modules", "commonjs", "esm", "require", "exports"]
            },
            {
                q: "What are popular Node.js frameworks and their use cases?",
                a: "Express.js is minimal and flexible for APIs and web apps. NestJS provides TypeScript and structure for enterprise applications. Koa focuses on modern async/await middleware. Fastify emphasizes high performance. Meteor offers full-stack isomorphic development. Each framework serves different architectural needs and performance requirements.",
                r: "Express for simplicity, NestJS for enterprise structure, Fastify for performance-critical APIs.",
                tags: ["nodejs", "frameworks", "express", "nestjs", "koa", "fastify", "meteor"]
            },
            {
                q: "How does Node.js handle file system operations and streams?",
                a: "Node.js provides fs module for file operations (readFile, writeFile, mkdir, etc.) with both synchronous and asynchronous versions. Streams enable processing data in chunks without loading everything into memory. Streams are used for file processing, HTTP requests, and real-time data handling with better memory efficiency.",
                r: "Use streams for large files or real-time data to avoid memory issues and improve performance.",
                tags: ["nodejs", "file-system", "streams", "fs-module", "async", "memory-efficiency"]
            },
            {
                q: "What is npm and how does it manage Node.js packages?",
                a: "npm (Node Package Manager) is the default package manager for Node.js. It handles dependency installation, version management, scripts, and publishing. package.json defines project dependencies and scripts, package-lock.json locks exact versions. npm enables sharing and consuming reusable code through the npm registry.",
                r: "npm install adds dependencies, npm run executes scripts, package.json manages project configuration.",
                tags: ["nodejs", "npm", "package-manager", "dependencies", "package-json", "registry"]
            },
            {
                q: "How do React and Node.js work together in full-stack applications?",
                a: "React handles the frontend UI and user interactions, while Node.js provides backend APIs, database operations, and server-side logic. They communicate via HTTP/HTTPS requests (REST APIs or GraphQL). Node.js can also serve React applications, handle authentication, and provide real-time features through WebSockets.",
                r: "React for UI, Node.js for API: full-stack JavaScript with consistent language and tooling.",
                tags: ["react", "nodejs", "full-stack", "api", "mern", "mean", "javascript"]
            },
            {
                q: "What is React Router and how does it handle client-side routing?",
                a: "React Router is a library that enables client-side routing in React applications. It maps URLs to components, handles navigation without page reloads, supports nested routes, route guards, and programmatic navigation. This creates single-page applications (SPAs) with fast, smooth user experiences.",
                r: "React Router enables SPA navigation: change URL and content without full page reloads.",
                tags: ["react", "react-router", "routing", "spa", "navigation", "client-side"]
            },
            {
                q: "What is Express.js middleware and how does it work?",
                a: "Express middleware functions process requests before they reach route handlers. They handle authentication, logging, error handling, body parsing, and custom logic. Middleware runs in sequence, with next() passing control to the next function. This modular approach enables reusable request processing logic.",
                r: "Middleware functions are the building blocks of Express applications for request processing.",
                tags: ["nodejs", "express", "middleware", "request-handling", "authentication", "logging"]
            },
            {
                q: "How does React handle forms and user input?",
                a: "React forms can be controlled (component state manages input values) or uncontrolled (DOM manages values). Controlled forms provide better validation and state management. React handles form events (onChange, onSubmit), input validation, and state updates. Libraries like Formik and React Hook Form simplify complex form handling.",
                r: "Controlled components give React full control over form values and validation.",
                tags: ["react", "forms", "user-input", "controlled-components", "validation", "formik"]
            },
            {
                q: "What are REST APIs and how does Node.js implement them?",
                a: "REST APIs use HTTP methods (GET, POST, PUT, DELETE) to perform CRUD operations on resources. Node.js implements REST APIs using Express.js with route handlers, middleware, and database integration. REST APIs return JSON data, handle status codes, and follow stateless principles for scalability.",
                r: "REST APIs enable React frontend to communicate with Node.js backend via HTTP requests.",
                tags: ["nodejs", "rest-api", "express", "http", "crud", "json", "api-design"]
            },
            {
                q: "What are React lifecycle methods and their modern equivalents?",
                a: "Class components use lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount). Functional components use hooks: useEffect replaces all lifecycle methods, useLayoutEffect for DOM measurements, and custom hooks for reusable lifecycle logic. Hooks provide better composition and cleaner code.",
                r: "useEffect with dependency array replaces componentDidMount, componentDidUpdate, and componentWillUnmount.",
                tags: ["react", "lifecycle", "useeffect", "componentdidmount", "hooks", "class-components"]
            },
            {
                q: "How does Node.js handle database operations and connections?",
                a: "Node.js connects to databases through drivers and ORMs. MongoDB (Mongoose), PostgreSQL (pg, Sequelize), MySQL (mysql2, Prisma), and Redis (ioredis) are popular choices. Connection pooling manages database connections efficiently. ORMs provide object-oriented database access with validation and relationships.",
                r: "Use Mongoose for MongoDB, Sequelize for SQL databases, Prisma for type-safe database access.",
                tags: ["nodejs", "database", "mongodb", "postgresql", "orm", "mongoose", "sequelize", "prisma"]
            },
            {
                q: "What is React Context API and when should you use it?",
                a: "React Context provides a way to pass data through the component tree without prop drilling. It's useful for global state like themes, user authentication, or language preferences. Context consists of createContext(), Provider, and useContext hook. Avoid overusing Context for frequently changing state.",
                r: "Use Context for global data that doesn't change frequently, not for high-frequency state updates.",
                tags: ["react", "context", "usecontext", "provider", "global-state", "prop-drilling"]
            },
            {
                q: "What is JWT authentication and how do React and Node.js implement it?",
                a: "JWT (JSON Web Tokens) are tokens that contain user information for authentication. Node.js generates JWTs on login, signs them with a secret key, and sends them to clients. React stores JWTs (localStorage, cookies) and sends them with API requests. Middleware on Node.js validates JWTs for protected routes.",
                r: "JWT enables stateless authentication: server verifies token without storing session state.",
                tags: ["react", "nodejs", "authentication", "jwt", "security", "tokens", "api"]
            },
            {
                q: "How do React and Node.js handle real-time communication with WebSockets?",
                a: "WebSockets enable bidirectional real-time communication. Node.js uses libraries like Socket.IO or ws to handle WebSocket connections. React connects to WebSocket servers, sends/receives messages, and updates UI in real-time. Use cases include chat apps, live notifications, and collaborative features.",
                r: "Socket.IO simplifies WebSockets with fallbacks and room-based messaging.",
                tags: ["react", "nodejs", "websockets", "socket.io", "real-time", "communication", "live-updates"]
            },
            {
                q: "What are React performance optimization techniques?",
                a: "React optimization includes React.memo for component memoization, useMemo for expensive calculations, useCallback for function memoization, code splitting with lazy loading, virtualization for long lists, and avoiding unnecessary re-renders. DevTools Profiler helps identify performance bottlenecks.",
                r: "Use React.memo to prevent re-renders, useMemo for expensive calculations, lazy loading for code splitting.",
                tags: ["react", "performance", "optimization", "react-memo", "usememo", "usecallback", "code-splitting"]
            },
            {
                q: "How does Node.js handle error handling and debugging?",
                a: "Node.js error handling uses try/catch for synchronous code, .catch() for promises, and error-first callbacks for legacy code. Global error handlers catch uncaught errors. Debugging uses Node.js debugger, Chrome DevTools, console.log, and source maps. Proper error handling prevents crashes and improves debugging.",
                r: "Use try/catch for sync operations, .catch() for promises, and process.on('uncaughtException') for global errors.",
                tags: ["nodejs", "error-handling", "debugging", "try-catch", "promises", "callbacks", "devtools"]
            },
            {
                q: "What is deployment for React and Node.js applications?",
                a: "React apps deploy to static hosting (Netlify, Vercel, S3) after building. Node.js apps deploy to cloud platforms (Heroku, AWS, DigitalOcean), containers (Docker), or serverless functions. CI/CD pipelines automate testing and deployment. Environment variables manage configuration across environments.",
                r: "Build React for static hosting, deploy Node.js to cloud platforms with proper environment configuration.",
                tags: ["react", "nodejs", "deployment", "hosting", "docker", "ci-cd", "environment-variables"]
            },
            {
                q: "What is programming and why is it important in modern society?",
                a: "Programming is the process of creating instructions for computers to perform specific tasks. It's fundamental to modern technology, enabling software development, automation, data analysis, and digital innovation. Programming drives everything from websites and mobile apps to artificial intelligence and scientific research.",
                r: "Programming transforms ideas into functional technology that powers our digital world.",
                tags: ["programming", "concepts", "fundamentals", "technology", "society"]
            },
            {
                q: "What are the core programming paradigms and their differences?",
                a: "Main paradigms include procedural (step-by-step instructions), object-oriented (objects with properties and methods), functional (pure functions and immutability), and logic programming (rules and facts). Each paradigm offers different approaches to problem-solving, code organization, and thinking about computation.",
                r: "Choose paradigms based on problem complexity: procedural for simple tasks, OOP for complex systems, functional for data processing.",
                tags: ["programming", "paradigms", "procedural", "object-oriented", "functional", "logic"]
            },
            {
                q: "What is computational thinking and how does it relate to programming?",
                a: "Computational thinking involves breaking down complex problems, identifying patterns, abstracting key concepts, and creating step-by-step solutions. It's the foundation of programming, teaching logical reasoning, problem decomposition, and algorithmic thinking essential for writing effective code.",
                r: "Computational thinking is the mental framework for approaching programming problems systematically.",
                tags: ["programming", "computational-thinking", "problem-solving", "algorithms", "logic"]
            },
            {
                q: "What are algorithms and why are they fundamental to programming?",
                a: "Algorithms are step-by-step procedures for solving problems or accomplishing tasks. They're the core of programming, determining how efficiently problems are solved. Understanding algorithms involves time/space complexity, optimization, and choosing the right approach for specific problems.",
                r: "Good algorithms solve problems efficiently; poor algorithms waste resources and time.",
                tags: ["programming", "algorithms", "complexity", "optimization", "problem-solving"]
            },
            {
                q: "What is abstraction in programming and why is it important?",
                a: "Abstraction hides complex implementation details while exposing essential functionality. It enables programmers to work with high-level concepts without worrying about low-level details. Abstraction appears in functions, classes, APIs, and interfaces, making code manageable and reusable.",
                r: "Abstraction lets you use complex systems without understanding their internal workings.",
                tags: ["programming", "abstraction", "encapsulation", "interfaces", "complexity-management"]
            },
            {
                q: "What are data structures and their role in programming?",
                a: "Data structures organize and store data efficiently for specific operations. Common structures include arrays, linked lists, stacks, queues, trees, graphs, and hash tables. Choosing the right data structure dramatically impacts algorithm performance and code efficiency.",
                r: "Data structures are to programs what organizational systems are to libraries: they make finding and using data efficient.",
                tags: ["programming", "data-structures", "arrays", "trees", "graphs", "efficiency"]
            },
            {
                q: "What is software architecture and why does it matter?",
                a: "Software architecture is the high-level structure of software systems, including components, relationships, and design principles. Good architecture ensures maintainability, scalability, and reliability. It involves patterns like MVC, MVP, MVVM, and component-based architectures.",
                r: "Architecture is the blueprint that determines how software components work together.",
                tags: ["programming", "architecture", "design", "scalability", "patterns", "structure"]
            },
            {
                q: "What is the difference between compiled and interpreted languages?",
                a: "Compiled languages (C++, Java) translate source code to machine code before execution, resulting in faster performance. Interpreted languages (Python, JavaScript) execute code line-by-line at runtime, offering flexibility and easier debugging. Some languages use hybrid approaches (JIT compilation).",
                r: "Compiled for performance, interpreted for flexibility; modern languages often combine both approaches.",
                tags: ["programming", "languages", "compilation", "interpretation", "performance", "execution"]
            },
            {
                q: "What is version control and why is it essential for programming?",
                a: "Version control systems (like Git) track changes to code over time, enabling collaboration, rollback to previous versions, and parallel development. They provide history, branching, merging, and conflict resolution. Version control is fundamental to team development and code management.",
                r: "Version control is like a time machine for code: you can go back, branch out, and merge changes safely.",
                tags: ["programming", "version-control", "git", "collaboration", "code-management"]
            },
            {
                q: "What are programming design patterns and their benefits?",
                a: "Design patterns are reusable solutions to common programming problems. Patterns like Singleton, Factory, Observer, and MVC provide proven approaches to object creation, structural organization, and behavior management. They improve code quality, maintainability, and developer communication.",
                r: "Design patterns are battle-tested solutions that save time and prevent common mistakes.",
                tags: ["programming", "design-patterns", "singleton", "factory", "observer", "mvc", "solutions"]
            },
            {
                q: "What is debugging and how do programmers approach it?",
                a: "Debugging is the process of finding and fixing code errors. Approaches include reading code carefully, adding logging, using debuggers, reproducing issues systematically, and testing hypotheses. Good debugging combines analytical thinking, systematic investigation, and understanding of system behavior.",
                r: "Debugging is detective work: gather evidence, form hypotheses, and test them systematically.",
                tags: ["programming", "debugging", "troubleshooting", "problem-solving", "testing"]
            },
            {
                q: "What is code optimization and when should it be done?",
                a: "Code optimization improves performance, memory usage, or efficiency. It should be done after correct functionality is achieved, guided by profiling data. Premature optimization can lead to complex, hard-to-maintain code. Focus on algorithms, data structures, and bottlenecks identified through measurement.",
                r: "First make it work, then make it right, then make it fast - but only if measurements show it's needed.",
                tags: ["programming", "optimization", "performance", "profiling", "efficiency", "premature-optimization"]
            },
            {
                q: "What is software testing and why does it matter?",
                a: "Testing verifies that software works correctly and meets requirements. Types include unit tests (individual components), integration tests (component interactions), and system tests (complete functionality). Testing prevents bugs, ensures reliability, and enables confident code changes and refactoring.",
                r: "Testing is quality assurance: it catches bugs before users do and enables safe code evolution.",
                tags: ["programming", "testing", "quality", "unit-tests", "integration-tests", "reliability"]
            },
            {
                q: "What is code readability and why does it matter?",
                a: "Code readability refers to how easily humans can understand code. It's crucial for maintenance, collaboration, and debugging. Readable code uses clear naming, consistent style, appropriate comments, and logical structure. Good readability reduces bugs and development time.",
                r: "Code is read more often than it's written, so prioritize readability over cleverness.",
                tags: ["programming", "readability", "maintainability", "style", "naming", "documentation"]
            },
            {
                q: "What is software development lifecycle (SDLC) and its phases?",
                a: "SDLC describes the process of creating software: requirements analysis, design, implementation, testing, deployment, and maintenance. Different models include Waterfall (sequential), Agile (iterative), and DevOps (continuous). SDLC provides structure for managing complex software projects.",
                r: "SDLC provides a roadmap from idea to working software and ongoing maintenance.",
                tags: ["programming", "sdlc", "development-process", "agile", "waterfall", "project-management"]
            },
            {
                q: "What is API design and what makes a good API?",
                a: "APIs (Application Programming Interfaces) define how software components communicate. Good APIs are intuitive, consistent, well-documented, and handle errors gracefully. They balance simplicity with power, provide clear contracts, and consider versioning and backward compatibility.",
                r: "Good APIs are like good user interfaces: they're intuitive, consistent, and handle errors gracefully.",
                tags: ["programming", "api", "interface-design", "documentation", "contracts", "communication"]
            },
            {
                q: "What is error handling and how should it be implemented?",
                a: "Error handling anticipates and manages unexpected situations gracefully. Approaches include try-catch blocks, error codes, logging, and user-friendly messages. Good error handling prevents crashes, provides useful debugging information, and maintains system stability.",
                r: "Handle errors at the appropriate level: catch what you can handle, let what you can't bubble up.",
                tags: ["programming", "error-handling", "exceptions", "robustness", "stability", "logging"]
            },
            {
                q: "What is code modularity and why is it important?",
                a: "Modularity breaks code into independent, reusable components with clear interfaces. It improves maintainability, reusability, testing, and collaboration. Modular code isolates changes, reduces complexity, and enables parallel development. Modules can be functions, classes, or entire applications.",
                r: "Modularity is like building with LEGO blocks: each piece is independent but works with others.",
                tags: ["programming", "modularity", "components", "reusability", "maintainability", "separation-of-concerns"]
            },
            {
                q: "What is technical debt and how should programmers manage it?",
                a: "Technical debt refers to the cost of rework caused by choosing easy solutions now instead of better ones that would take longer. It accumulates through shortcuts, poor design, and outdated code. Manage it by tracking, prioritizing, and gradually paying it down through refactoring.",
                r: "Technical debt is like financial debt: borrow when necessary, but have a plan to pay it back.",
                tags: ["programming", "technical-debt", "refactoring", "code-quality", "maintenance", "tradeoffs"]
            },
            {
                q: "What is continuous integration and deployment (CI/CD)?",
                a: "CI/CD automates the software delivery process: CI automatically builds and tests code changes, CD automatically deploys successful changes to production. This enables rapid, reliable releases, early bug detection, and consistent deployment processes. Tools include Jenkins, GitHub Actions, and GitLab CI.",
                r: "CI/CD transforms manual, error-prone deployments into automated, reliable processes.",
                tags: ["programming", "cicd", "automation", "deployment", "testing", "devops"]
            },
            {
                q: "What is code documentation and why is it essential?",
                a: "Documentation explains code purpose, usage, and design. It includes comments, README files, API docs, and architectural diagrams. Good documentation enables knowledge sharing, onboarding, maintenance, and effective collaboration. Documentation should be accurate, concise, and targeted to different audiences.",
                r: "Documentation is the user manual for your code: it helps others (and future you) understand and use it effectively.",
                tags: ["programming", "documentation", "comments", "knowledge-sharing", "maintenance", "collaboration"]
            },
            {
                q: "What is software scalability and how is it achieved?",
                a: "Scalability is the ability to handle increased load through growth. Types include vertical scaling (more resources) and horizontal scaling (more machines). Achieve it through efficient algorithms, distributed systems, load balancing, caching, and database optimization. Design for scalability from the start.",
                r: "Scalability means your software can grow with your users without falling apart.",
                tags: ["programming", "scalability", "performance", "distributed-systems", "load-balancing", "growth"]
            },
            {
                q: "What is software security and fundamental security principles?",
                a: "Software security protects systems from threats and vulnerabilities. Principles include least privilege, defense in depth, secure by default, and fail safely. Key practices include input validation, authentication, authorization, encryption, and regular security audits. Security must be considered throughout development.",
                r: "Security is not an afterthought: build it in from the beginning and assume nothing is trusted.",
                tags: ["programming", "security", "authentication", "encryption", "vulnerabilities", "secure-coding"]
            },
            {
                q: "What is software maintenance and why does it dominate development costs?",
                a: "Software maintenance includes bug fixes, feature additions, performance improvements, and compatibility updates. It typically consumes 60-80% of total software costs over its lifetime. Good design, documentation, and testing reduce maintenance burden and extend software usefulness.",
                r: "Writing code is just the beginning; maintaining it is the long-term commitment.",
                tags: ["programming", "maintenance", "support", "lifecycle", "costs", "longevity"]
            },
            {
                q: "What are programming best practices and how do they emerge?",
                a: "Best practices are proven approaches that improve code quality, maintainability, and development efficiency. They emerge from collective experience, testing, and refinement over time. Examples include DRY (Don't Repeat Yourself), SOLID principles, and consistent coding standards. Adapt practices to your specific context.",
                r: "Best practices are guidelines, not rules: understand the principles behind them and adapt thoughtfully.",
                tags: ["programming", "best-practices", "dry", "solid", "standards", "quality", "experience"]
            },
            {
                q: "What is software performance and how do programmers optimize it?",
                a: "Software performance measures speed, responsiveness, and resource usage. Optimization involves profiling to identify bottlenecks, choosing efficient algorithms, optimizing data structures, reducing memory allocation, and leveraging caching. Measure before optimizing and focus on user-noticeable improvements.",
                r: "Performance optimization requires measurement: don't optimize what isn't actually slow.",
                tags: ["programming", "performance", "optimization", "profiling", "bottlenecks", "efficiency"]
            },
            {
                q: "What is code refactoring and when should it be done?",
                a: "Refactoring improves code structure without changing functionality. It's done when code becomes hard to maintain, contains duplication, or needs design improvements. Safe refactoring requires comprehensive tests, small incremental changes, and verification after each change.",
                r: "Refactoring is cleaning up the house: make small improvements while keeping everything working.",
                tags: ["programming", "refactoring", "code-quality", "maintenance", "structure", "clean-code"]
            },
            {
                q: "What is software quality and how is it measured?",
                a: "Software quality includes functionality, reliability, performance, usability, security, and maintainability. It's measured through testing, code reviews, metrics (complexity, coverage), user feedback, and monitoring. Quality is built through processes, standards, and continuous improvement.",
                r: "Quality is multidimensional: good software works reliably, performs well, and is maintainable.",
                tags: ["programming", "quality", "metrics", "testing", "code-reviews", "standards"]
            },
            {
                q: "What is programming language evolution and selection criteria?",
                a: "Programming languages evolve to address new problems, incorporate research advances, and improve developer experience. Selection criteria include problem domain, performance needs, ecosystem support, team expertise, and long-term maintenance. Choose languages based on specific project requirements and constraints.",
                r: "No perfect language exists: choose the right tool for the specific job and context.",
                tags: ["programming", "languages", "evolution", "selection", "tradeoffs", "ecosystem"]
            },
            {
                q: "What is software engineering vs programming?",
                a: "Programming focuses on writing code, while software engineering encompasses the entire lifecycle: requirements, design, testing, deployment, and maintenance. Software engineering applies systematic, disciplined, quantifiable approaches to software development, considering scale, teams, and long-term evolution.",
                r: "Programming is building; software engineering is engineering entire systems that last and evolve.",
                tags: ["programming", "software-engineering", "discipline", "methodology", "scale", "lifecycle"]
            },
            {
                q: "What is collaborative programming and how does it work effectively?",
                a: "Collaborative programming involves multiple developers working together on codebases. Effective collaboration requires clear communication, coding standards, version control, code reviews, shared understanding, and conflict resolution. Practices include pair programming, mob programming, and distributed team coordination.",
                r: "Good collaboration turns individual programmers into high-performing teams.",
                tags: ["programming", "collaboration", "teamwork", "code-reviews", "communication", "version-control"]
            },
            {
                q: "What is software portability and why does it matter?",
                a: "Portability is the ability of software to run across different platforms, operating systems, or environments. It reduces development effort, increases user base, and provides flexibility. Achieve portability through standard APIs, platform abstraction, avoiding platform-specific code, and thorough testing.",
                r: "Portable software reaches more users with less platform-specific development effort.",
                tags: ["programming", "portability", "cross-platform", "compatibility", "standards", "abstraction"]
            },
            {
                q: "What is software accessibility and inclusive programming?",
                a: "Accessibility ensures software works for people with disabilities, including visual, auditory, motor, and cognitive impairments. Inclusive programming considers diverse users, follows WCAG guidelines, provides alternative input methods, and ensures compatibility with assistive technologies.",
                r: "Accessible software serves all users, regardless of their abilities or circumstances.",
                tags: ["programming", "accessibility", "inclusive-design", "wcag", "assistive-technology", "universal-access"]
            },
            {
                q: "What is software ethics and responsible programming?",
                a: "Software ethics considers the impact of code on users, society, and stakeholders. It includes privacy protection, data security, algorithmic fairness, transparency, and avoiding harmful applications. Responsible programming requires considering consequences, biases, and long-term societal effects.",
                r: "Programmers have ethical responsibilities: consider how your code affects people and society.",
                tags: ["programming", "ethics", "responsibility", "privacy", "fairness", "social-impact"]
            },
            {
                q: "What is software internationalization and localization?",
                a: "Internationalization (i18n) designs software to support multiple languages and regions without code changes. Localization (l10n) adapts software for specific markets through translation, cultural adaptation, and regional formatting. Both enable global software distribution and user experience.",
                r: "Internationalization prepares software for the world; localization adapts it for specific regions.",
                tags: ["programming", "internationalization", "localization", "globalization", "translation", "cultural-adaptation"]
            },
            {
                q: "What is software observability and monitoring?",
                a: "Observability is the ability to understand system internal states through external outputs. It includes logging, metrics, tracing, and alerting. Monitoring helps detect issues, understand performance, and make data-driven decisions about system behavior and improvements.",
                r: "Observability lets you understand what your software is doing, especially when things go wrong.",
                tags: ["programming", "observability", "monitoring", "logging", "metrics", "tracing", "operations"]
            },
            {
                q: "What is software resilience and fault tolerance?",
                a: "Resilience enables systems to continue operating despite failures. Techniques include redundancy, circuit breakers, retry mechanisms, graceful degradation, and disaster recovery. Fault-tolerant systems anticipate failures and have strategies to handle them without complete service interruption.",
                r: "Resilient systems expect failures and have plans to handle them gracefully.",
                tags: ["programming", "resilience", "fault-tolerance", "redundancy", "reliability", "disaster-recovery"]
            },
            {
                q: "What is software configuration management?",
                a: "Configuration management controls and tracks changes to software, infrastructure, and environments. It includes version control, environment management, deployment automation, and change tracking. Proper configuration management ensures consistency, reproducibility, and traceability across development and production.",
                r: "Configuration management ensures everyone works with the same setup and changes are tracked properly.",
                tags: ["programming", "configuration-management", "version-control", "environments", "automation", "consistency"]
            },
            {
                q: "What is software capacity planning and scaling strategies?",
                a: "Capacity planning anticipates future resource needs based on growth projections and usage patterns. Scaling strategies include vertical scaling (upgrading resources) and horizontal scaling (adding instances). Effective planning prevents performance issues and ensures system availability during growth.",
                r: "Plan for growth before you need it; scaling is harder when you're already at capacity.",
                tags: ["programming", "capacity-planning", "scaling", "performance", "growth", "resource-management"]
            },
            {
                q: "What is software compliance and regulatory requirements?",
                a: "Compliance ensures software meets legal, industry, and regulatory requirements like GDPR, HIPAA, and PCI-DSS. It involves data protection, security standards, audit trails, and documentation. Compliance protects organizations from legal risks and builds user trust.",
                r: "Compliance isn't optional: understand and implement requirements for your industry and region.",
                tags: ["programming", "compliance", "regulations", "gdpr", "security", "legal-requirements"]
            },
            {
                q: "What is software innovation and emerging technologies?",
                a: "Software innovation involves applying new technologies and approaches to solve problems better. Emerging technologies include AI/ML, blockchain, quantum computing, edge computing, and IoT. Successful innovation balances new possibilities with practical implementation and user needs.",
                r: "Innovation combines new technology with real problems to create valuable solutions.",
                tags: ["programming", "innovation", "emerging-tech", "ai", "blockchain", "quantum", "future-trends"]
            },
            {
                q: "What is software sustainability and green programming?",
                a: "Software sustainability considers environmental impact, resource efficiency, and long-term maintainability. Green programming optimizes for energy efficiency, reduces computational waste, and considers carbon footprint. Sustainable software is maintainable, efficient, and environmentally responsible.",
                r: "Sustainable software considers not just users, but also environmental impact and long-term viability.",
                tags: ["programming", "sustainability", "green-computing", "environmental-impact", "efficiency", "responsibility"]
            },
            {
                q: "What is software documentation and knowledge management?",
                a: "Documentation captures and shares knowledge about software design, implementation, and usage. Knowledge management ensures information is accessible, current, and useful. Good documentation includes API docs, architecture diagrams, setup guides, and troubleshooting information.",
                r: "Documentation preserves knowledge and enables effective collaboration and maintenance.",
                tags: ["programming", "documentation", "knowledge-management", "sharing", "collaboration", "preservation"]
            },
            {
                q: "What is software risk management and mitigation?",
                a: "Risk management identifies, assesses, and mitigates potential software project risks. Risks include technical challenges, timeline delays, budget overruns, and security threats. Mitigation strategies include contingency planning, regular assessment, and proactive problem-solving.",
                r: "Good risk management anticipates problems and has plans before they become crises.",
                tags: ["programming", "risk-management", "mitigation", "planning", "contingency", "project-management"]
            },
            {
                q: "What is software user experience and human-centered design?",
                a: "User experience (UX) focuses on making software usable, efficient, and enjoyable for humans. Human-centered design involves understanding user needs, iterative testing, and continuous improvement based on feedback. Good UX leads to higher adoption and satisfaction.",
                r: "Technical excellence matters, but user experience determines whether software succeeds.",
                tags: ["programming", "ux", "user-experience", "human-centered-design", "usability", "design-thinking"]
            },
            {
                q: "What is software analytics and data-driven development?",
                a: "Software analytics collect and analyze usage data to inform development decisions. Data-driven development uses metrics, user behavior analysis, and A/B testing to guide feature development, bug fixes, and improvements. Analytics help prioritize work based on real user needs.",
                r: "Data-driven decisions replace assumptions with evidence about what users actually need and do.",
                tags: ["programming", "analytics", "data-driven", "metrics", "user-behavior", "evidence-based"]
            },
            {
                q: "What is software interoperability and integration?",
                a: "Interoperability enables different software systems to work together effectively. Integration connects disparate systems through APIs, data formats, and communication protocols. Good interoperability reduces silos, enables data flow, and creates cohesive user experiences across systems.",
                r: "Interoperability turns isolated systems into integrated ecosystems that work together seamlessly.",
                tags: ["programming", "interoperability", "integration", "apis", "systems-thinking", "connectivity"]
            },
            {
                q: "What is software testing automation and quality assurance?",
                a: "Testing automation uses tools to run tests automatically, improving coverage and efficiency. Quality assurance encompasses processes, tools, and practices to ensure software meets requirements. Automated testing includes unit tests, integration tests, and UI tests run continuously.",
                r: "Automated testing catches regressions quickly and enables confident, rapid development.",
                tags: ["programming", "testing", "automation", "quality-assurance", "continuous-testing", "regression-testing"]
            },
            {
                q: "What is software deployment strategies and release management?",
                a: "Deployment strategies include blue-green deployments, canary releases, rolling updates, and feature flags. Release management coordinates software delivery, testing, and deployment. Good strategies minimize downtime, reduce risk, and enable quick rollbacks if issues arise.",
                r: "Smart deployment strategies release software confidently while minimizing user impact.",
                tags: ["programming", "deployment", "release-management", "blue-green", "canary", "feature-flags"]
            },
            {
                q: "What is software performance engineering and optimization?",
                a: "Performance engineering focuses on building fast, efficient software from the start rather than optimizing later. It involves understanding system bottlenecks, choosing appropriate algorithms, optimizing database queries, and implementing caching strategies. Performance is a feature, not an afterthought.",
                r: "Performance engineering builds speed in from the beginning rather than adding it later.",
                tags: ["programming", "performance", "engineering", "optimization", "bottlenecks", "efficiency"]
            },
            {
                q: "What is software legacy modernization and migration?",
                a: "Legacy modernization updates outdated software systems to modern architectures and technologies. Migration strategies include gradual refactoring, re-platforming, or complete rewrites. Modernization improves maintainability, performance, and security while preserving business value.",
                r: "Modernization balances preserving existing value with adopting modern practices and technologies.",
                tags: ["programming", "legacy-modernization", "migration", "refactoring", "technical-debt", "modernization"]
            },
            {
                q: "What is software team organization and collaboration patterns?",
                a: "Team organization affects software development effectiveness. Patterns include cross-functional teams, pair programming, mob programming, and guilds. Good organization balances autonomy with coordination, enables knowledge sharing, and aligns team structure with project needs.",
                r: "Effective team organization turns individual programmers into collaborative, high-performing units.",
                tags: ["programming", "team-organization", "collaboration", "agile", "cross-functional", "knowledge-sharing"]
            },
            {
                q: "What is software cost estimation and project planning?",
                a: "Cost estimation predicts resources needed for software projects. Planning involves scope definition, timeline creation, resource allocation, and risk assessment. Techniques include story points, function points, and historical data. Accurate estimation requires experience and iterative refinement.",
                r: "Good estimation balances optimism with realism based on experience and historical data.",
                tags: ["programming", "cost-estimation", "project-planning", "resource-management", "timeline", "budgeting"]
            },
            {
                q: "What is software requirements engineering and analysis?",
                a: "Requirements engineering captures, analyzes, validates, and manages software requirements. It includes stakeholder analysis, requirement gathering, specification, and verification. Good requirements prevent misunderstandings and ensure the software solves the right problems.",
                r: "Clear requirements are the foundation: building the wrong thing perfectly is still failure.",
                tags: ["programming", "requirements", "analysis", "specification", "stakeholders", "validation"]
            },
            {
                q: "What is software prototyping and iterative development?",
                a: "Prototyping creates early versions to gather feedback and validate ideas. Iterative development builds software incrementally through repeated cycles of development and feedback. Both approaches reduce risk, improve user satisfaction, and enable course correction based on real user input.",
                r: "Prototypes and iterations reduce the risk of building the wrong thing by getting early feedback.",
                tags: ["programming", "prototyping", "iterative-development", "feedback", "agile", "user-validation"]
            },
            {
                q: "What is software benchmarking and performance measurement?",
                a: "Benchmarking measures software performance against standards or competitors. Performance metrics include response time, throughput, resource usage, and scalability. Regular benchmarking identifies performance regressions and guides optimization efforts.",
                r: "You can't improve what you don't measure: benchmarking provides the data for performance decisions.",
                tags: ["programming", "benchmarking", "performance-measurement", "metrics", "optimization", "comparison"]
            },
            {
                q: "What is software vendor management and third-party integration?",
                a: "Vendor management evaluates, selects, and manages third-party software and services. Integration connects external systems through APIs, data exchange, and workflow coordination. Good vendor management balances benefits with risks like dependencies and security.",
                r: "Third-party software can accelerate development but creates dependencies that must be managed carefully.",
                tags: ["programming", "vendor-management", "third-party", "integration", "dependencies", "risk-management"]
            },
            {
                q: "What is software disaster recovery and business continuity?",
                a: "Disaster recovery plans restore systems after catastrophic failures. Business continuity ensures essential operations continue during disruptions. Strategies include backups, redundant systems, emergency procedures, and regular testing. Planning minimizes downtime and data loss.",
                r: "Disaster recovery planning prepares for the worst case to ensure business survival.",
                tags: ["programming", "disaster-recovery", "business-continuity", "backup", "redundancy", "emergency-planning"]
            },
            {
                q: "What is software knowledge sharing and technical communication?",
                a: "Knowledge sharing distributes expertise across teams and organizations. Technical communication conveys complex concepts clearly through documentation, presentations, and code reviews. Effective sharing accelerates learning, prevents knowledge silos, and improves team capability.",
                r: "Shared knowledge multiplies team effectiveness and prevents critical information from being lost.",
                tags: ["programming", "knowledge-sharing", "communication", "documentation", "mentoring", "team-learning"]
            },
            {
                q: "What is software career development and skill advancement?",
                a: "Career development in programming involves continuous learning, skill diversification, and specialization. Areas include technical depth, architectural thinking, leadership, and domain expertise. Advancement requires staying current with technologies and understanding business context.",
                r: "Programming careers grow through continuous learning and expanding beyond pure technical skills.",
                tags: ["programming", "career-development", "skills", "learning", "advancement", "professional-growth"]
            },
            {
                q: "What is software community involvement and open source contribution?",
                a: "Community involvement includes participating in open source projects, attending conferences, and sharing knowledge. Contributing to open source builds skills, reputation, and network. Community engagement drives innovation and collective problem-solving in software development.",
                r: "Open source contribution builds skills, reputation, and gives back to the programming community.",
                tags: ["programming", "open-source", "community", "contribution", "networking", "knowledge-sharing"]
            },
            {
                q: "What is software mentoring and knowledge transfer?",
                a: "Mentoring accelerates learning through guidance from experienced practitioners. Knowledge transfer ensures critical expertise spreads across teams. Effective mentoring pairs experienced developers with learners, provides constructive feedback, and builds organizational capability.",
                r: "Mentoring multiplies organizational expertise by developing talent and sharing experience.",
                tags: ["programming", "mentoring", "knowledge-transfer", "coaching", "talent-development", "organizational-learning"]
            },
            {
                q: "What is software innovation culture and experimentation?",
                a: "Innovation culture encourages experimentation, learning from failure, and continuous improvement. It requires psychological safety, time for exploration, and support for trying new approaches. Innovation cultures balance stability with creative exploration.",
                r: "Innovation cultures treat failure as learning and provide space for creative experimentation.",
                tags: ["programming", "innovation-culture", "experimentation", "learning", "creativity", "psychological-safety"]
            },
            {
                q: "What is software work-life balance and sustainable development?",
                a: "Sustainable development maintains productivity without burnout through reasonable work hours, adequate rest, and stress management. Work-life balance prevents fatigue, maintains code quality, and supports long-term career sustainability. Healthy teams produce better software consistently.",
                r: "Sustainable pace prevents burnout and maintains consistent quality over the long term.",
                tags: ["programming", "work-life-balance", "sustainability", "burnout-prevention", "health", "productivity"]
            },
            {
                q: "What is software future trends and emerging paradigms?",
                a: "Future trends include AI-assisted programming, quantum computing, edge computing, serverless architectures, and low-code/no-code platforms. Emerging paradigms like reactive programming, event-driven architectures, and distributed systems shape how software will be built and deployed.",
                r: "Stay curious about emerging trends but adopt them based on real value, not just novelty.",
                tags: ["programming", "future-trends", "emerging-paradigms", "ai-programming", "quantum", "evolution"]
            }
        ];

        // Function to copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);

            if (!codeElement) return;

            const code = codeElement.innerText;

            navigator.clipboard.writeText(code).then(() => {
                // Show copied feedback
                const copyBtn = codeElement.closest('.code-container').querySelector('.copy-btn');
                if (copyBtn) {
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';

                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy code: ', err);
            });
        }
    

        // Function to render table of contents
        function renderTOC() {
            const tocList = document.getElementById('tocList');
            if (!tocList) return;

            const source = currentQuestions && currentQuestions.length ? currentQuestions : data;
            const start = (currentPage - 1) * questionsPerPage;
            const end = start + questionsPerPage;

            const pageItems = source.slice(start, end);

            tocList.innerHTML = pageItems.map((item, index) => {
                const number = start + index + 1;
                const shortQ = item.q.substring(0, 50) + (item.q.length > 50 ? '...' : '');
                return `
                    <li class="toc-item">
                        <a href="#q-${number}" class="toc-link">
                            <span class="toc-number">${number}.</span>
                            <span class="toc-question">${shortQ}</span>
                        </a>
                    </li>
                `;
            }).join('');
        }

        // Function to handle search with highlighting
        function filterQuestions() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            if (!searchTerm) {
                currentQuestions = [...data];
                currentPage = 1;
                updatePagination();
                return;
            }
            
            currentQuestions = data.filter(item => 
                item.q.toLowerCase().includes(searchTerm) || 
                item.a.toLowerCase().includes(searchTerm) ||
                (item.r && item.r.toLowerCase().includes(searchTerm)) ||
                (item.tags && item.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
            );
            
            currentPage = 1;
            updatePagination();
            
            // Highlight search terms after rendering
            setTimeout(() => highlightSearchTerms(searchTerm), 100);
        }

        // Function to highlight search terms
        function highlightSearchTerms(searchTerm) {
            if (!searchTerm) return;
            
            const questionsContainer = document.getElementById('questionsContainer');
            const questionBoxes = questionsContainer.querySelectorAll('.q-box');
            
            questionBoxes.forEach(box => {
                const h3 = box.querySelector('h3');
                const paragraphs = box.querySelectorAll('p');
                
                // Highlight in question title
                if (h3) {
                    h3.innerHTML = highlightText(h3.textContent, searchTerm);
                }
                
                // Highlight in paragraphs
                paragraphs.forEach(p => {
                    p.innerHTML = highlightText(p.textContent, searchTerm);
                });
            });
        }

        // Function to highlight text
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<mark class="search-highlight">$1</mark>');
        }

        // Add CSS for search highlighting
        const searchHighlightStyle = document.createElement('style');
        searchHighlightStyle.textContent = `
            .search-highlight {
                background-color: #fef08a;
                color: #713f12;
                padding: 2px 4px;
                border-radius: 3px;
                font-weight: 500;
            }
        `;
        document.head.appendChild(searchHighlightStyle);

        // Function to render questions with pagination
        function renderQuestions(questionsToRender = data) {
            currentQuestions = [...questionsToRender];
            currentPage = 1; // Reset to first page when filtering
            updatePagination();
        }

        // Function to update pagination
        function updatePagination() {
            const questionsContainer = document.getElementById('questionsContainer');
            const pageInfo = document.getElementById('pageInfo');
            const prevPageBtn = document.getElementById('prevPage');
            const nextPageBtn = document.getElementById('nextPage');

            // Calculate pagination details
            const start = (currentPage - 1) * questionsPerPage;
            const end = start + questionsPerPage;
            const pageCount = Math.ceil(currentQuestions.length / questionsPerPage);

            // Render questions for the current page
            const questionsHTML = currentQuestions.slice(start, end).map((item, index) => {
                const questionNumber = (currentPage - 1) * questionsPerPage + index + 1;
                return `
                    <div class="q-box" id="q-${questionNumber}">
                        <h3>${item.q}</h3>
                        <div class="q-meta">
                            <span class="q-number">${questionNumber}</span>
                            <span class="q-tags">
                                ${item.tags.map(tag => `<span class="q-tag">${tag}</span>`).join('')}
                            </span>
                        </div>
                        <p>${item.a}</p>
                        ${item.r ? `<p class="q-result">${item.r}</p>` : ''}
                        ${item.c ? `
                            <div class="code-container">
                                <div class="code-header">
                                    <span class="code-title">Example Code</span>
                                    <button class="copy-btn" onclick="copyCode('code-${questionNumber}')">
                                        <i class="fas fa-copy"></i> Copy
                                    </button>
                                </div>
                                <pre><code id="code-${questionNumber}" class="language-javascript">${item.c}</code></pre>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            questionsContainer.innerHTML = questionsHTML;

            renderTOC();

            // Update page info
            if (pageInfo) {
                pageInfo.textContent = `Page ${currentPage} of ${pageCount} (${currentQuestions.length} questions)`;
            }

            // Update navigation buttons
            if (prevPageBtn) {
                prevPageBtn.disabled = currentPage === 1;
            }
            if (nextPageBtn) {
                nextPageBtn.disabled = currentPage === pageCount || pageCount === 0;
            }

            // Highlight code blocks
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        }

        // Pagination functions
        function nextPage() {
            const pageCount = Math.ceil(currentQuestions.length / questionsPerPage);
            if (currentPage < pageCount) {
                currentPage++;
                updatePagination();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                updatePagination();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            renderQuestions();

            // Pagination button event listeners
            const nextPageBtn = document.getElementById('nextPage');
            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', nextPage);
            }
            const prevPageBtn = document.getElementById('prevPage');
            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', prevPage);
            }

            const tocToggleBtn = document.getElementById('tocToggleBtn');
            const tocList = document.getElementById('tocList');
            if (tocToggleBtn && tocList) {
                tocToggleBtn.addEventListener('click', function() {
                    tocList.classList.toggle('toc-hidden');
                });
            }
            
            // Add search event listener
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', filterQuestions);
            }

            // Mobile menu functionality
            const mobileMenuToggle = document.getElementById('mobileMenuToggle');
            const mobileSidebar = document.getElementById('mobileSidebar');
            const mobileSidebarOverlay = document.getElementById('mobileSidebarOverlay');
            const mobileSidebarClose = document.getElementById('mobileSidebarClose');

            function openMobileMenu() {
                mobileSidebar.classList.add('active');
                mobileSidebarOverlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeMobileMenu() {
                mobileSidebar.classList.remove('active');
                mobileSidebarOverlay.classList.remove('active');
                document.body.style.overflow = '';
            }

            if (mobileMenuToggle) {
                mobileMenuToggle.addEventListener('click', openMobileMenu);
            }

            if (mobileSidebarClose) {
                mobileSidebarClose.addEventListener('click', closeMobileMenu);
            }

            if (mobileSidebarOverlay) {
                mobileSidebarOverlay.addEventListener('click', closeMobileMenu);
            }

            // Close mobile menu when clicking on TOC links
            const mobileTocLinks = mobileSidebar?.querySelectorAll('.toc-link');
            if (mobileTocLinks) {
                mobileTocLinks.forEach(link => {
                    link.addEventListener('click', closeMobileMenu);
                });
            }

            // Close mobile menu on escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && mobileSidebar?.classList.contains('active')) {
                    closeMobileMenu();
                }
            });
        });
    </script>
</body>
</html>